---
title:  iOS 底层
date:  2020年04月09日10:02:14
---

## [OC对象的本质](https://juejin.im/post/5ac81c75518825556534c0af)

> 一个NSObject对象占用多少内存？一个OC对象在内存中是如何布局的。

### NSObject 结构/在内存中的布局

* OC的对象结构都是通过基础C\C++的结构体实现的 用`clang -rewrite-objc`重写oc
* NSObject 以及其子类是以结构体的形式储存在内存中。
* 实例对象在内存中存储的信息包括 isa指针 + 其他成员变量
<!-- * 在继承关系下，子类的结构体会包含父类的结构体 -->
* NSObject对象中还有很多方法，但是方法是存储在class对象中的，类方法在meta class中

<img src="https://user-gold-cdn.xitu.io/2018/4/7/1629daf2209365e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" width="50%">

### 内存特点

0. 结构体中指针和成员变量所占的内存相加 + 对齐
* class_getInstanceSize获得的是实际占用的内存 malloc_size获得是实际分配的内存
1. **内存计算** malloc_size： 会16字节对齐 ； alloc是16的倍数.
2. 指针在64位架构中占据8字节 int 4字节
3. 内存对齐为两个原则： （如使用class_getInstanceSize）
* 前面的地址必须是后面的地址正数倍,不是就补齐。 
* 整个Struct的地址必须是最大字节的整数倍。

### 三种对象

* instance对象（实例对象） + class对象（类对象） + meta-class对象（元类对象）
* 【instance对象 】就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象，占用不同的内存
* 【class对象】每一个类在内存中有且只有一个class对象
* isa指针
* superclass指针
* 类的属性信息（@property），类的成员变量信息（ivar）
* 类的对象方法信息（instance method），类的协议信息（protocol）
* 【meta-class】每个类在内存中有且只有一个meta-class对象。 meta-class对象和class对象的内存结构是一样的    
* isa指针
* superclass指针
* 类的类方法的信息（class method）

### objc4 objc_class

<img src="https://user-gold-cdn.xitu.io/2018/4/14/162c48ff63abc565?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" width="50%">

## [分类](https://juejin.im/post/5aef0a3b518825670f7bc0f3)

* 分类结构体 category_t ；对象方法，类方法，协议，和属性都可以找到对应的存储方式
* runtime初始化函数 -> map_images -> `_getObjc2CategoryList` 
* 获取到分类列表之后，进行遍历，获取其中的方法，协议，属性等。可以看到最终都调用了 `remethodizeClass(cls)`;函数
* 从分类数组里面往三个数组里面存放分类数组里面存放的分类方法，属性以及协议放入对应mlist、proplists、protolosts数组中

> 问： Category的实现原理，以及Category为什么只能加方法不能加属性?

* 分类的实现原理是将category中的方法，属性，协议数据放在category_t结构体中，然后将结构体内的方法列表拷贝到类对象的方法列表中。
Category可以添加属性，但是并不会自动生成成员变量及set/get方法。因为category_t结构体中并不存在成员变量。
* 通过之前对对象的分析我们知道成员变量是存放在实例对象中的，并且编译的那一刻就已经决定好了。
* 而分类是在运行时才去加载的。那么我们就无法再程序运行时将分类的成员变量中添加到实例对象的结构体中。因此分类中不可以添加成员变量。

### 关联对象

<img src="https://user-gold-cdn.xitu.io/2018/5/14/1635a628a228e349?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" width="50%" />

* 关联对象并不是存储在被关联对象本身内存中，而是存储在全局的统一的一个 AssociationsManager
* AssociationsManager内部有一个AssociationsHashMap对象。
* 一个实例对象就对应一个ObjectAssociationMap，
* ObjectAssociationMap中存储着多个此实例对象的关联对象的key以及ObjcAssociation，
* ObjcAssociation中存储着关联对象的value和policy策略。
* 由此我们可以知道关联对象并不是放在了原来的对象里面，而是自己维护了一个全局的map用来存放每一个对象及其对应关联属性表格。

### weak 关联对象

用weak变量中转

```objc
-(void)setWeakvalue:(NSObject *)weakvalue {
__weak typeof(weakvalue) weakObj = weakvalue;
typeof(weakvalue) (^block)() = ^(){
return weakObj;
};
objc_setAssociatedObject(self, weakValueKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
-(NSObject *)weakvalue {
id (^block)() = objc_getAssociatedObject(self, weakValueKey);
return block();
}
```

### [weak属性的kvo]()

当弱持有的对象被释放掉时，runtime 会将对应的 weak 指针赋值为nil；但是操作对象是实例变量本身，而非通过 setter，因此无法触发 KVO，故而存在逻辑漏洞。

对weak属性的delloc 方法替换

```
- (void)setVc:(UIViewController *)vc
{
[self willChangeValueForKey:@"vc"];
objc_setAssociatedObject(self, @selector(vc), vc, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
if (vc) {
@weakify(self, vc);
[vc.rac_willDeallocSignal subscribeNext:^(id _) {
@strongify(self, vc);
if (self && self.vc == vc) {
self.vc = nil;
}
}];
}
[self didChangeValueForKey:@"vc"];
}
```

### 如何判断method是否被swizzling

* _cmd为"dosth"
* __PRETTY_FUNCTION__是一个编译器的宏，在编译期就由编译器决定了，以-[MyObject dosth]为例，在该方法内__PRETTY_FUNCTION__为"-[MyObject dosth]".而_cmd是方法的隐藏参数，是动态的
* 拿到了所有类的所有方法相对于该类的偏移

## KVO

>iOS用什么方式实现对一个对象的KVO？（KVO的本质是什么？）

*  当一个对象使用了KVO监听，iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类，
* 子类拥有自己的set方法实现，set方法实现内部会顺序调用willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，
* 而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。

> 如何手动触发KVO

* 自己调用willChangeValueForKey和didChangeValueForKey方法即可在不改变属性值的情况下手动触发KVO，并且这两个方法缺一不可。


## runloop

### RunLoop基本作用

* 保持程序持续运行，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行
* 处理App中的各种事件（比如：触摸事件，定时器事件，Selector事件等）
* 节省CPU资源，提高程序性能

###  RunLoop和线程间的关系

* 每条线程都有唯一的一个与之对应的RunLoop对象
* RunLoop保存在一个全局的Dictionary里，线程作为key,RunLoop作为value
* 主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建
* RunLoop在第一次获取时创建，在线程结束时销毁

### Source1/Source0

* Source1 : 基于Port的线程间通信
* Source0 : 触摸事件，PerformSelectors
* 触发了事件（触摸/锁屏/摇晃等）
* IOKit.framework生成一个 IOHIDEvent
* Source1就会接收IOHIDEvent
* 回调内Source0，Source0 再触发 _UIApplicationHandleEventQueue()

### CFRunLoopModeRef

* 一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source、Timer、Observer
* 这样做主要是为了分隔开不同组的Source、Timer、Observer，让其互不影响。
* 如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出
* kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行
2. UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响
5. kCFRunLoopCommonModes:

### CFRunLoopObserverRef

* 即将进入RunLoop
* 即将处理Timer
* 即将处理Source
* 即将进入休眠
* 刚从休眠中唤醒
* 即将退出RunLoop

### 常驻线程

创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，

### autoreleasePool

当RunLoop开启时，就会自动创建一个自动释放池，当RunLoop在休息之前会释放掉自动释放池的东西，然后重新创建一个新的空的自动释放池，当RunLoop被唤醒重新开始跑圈时，Timer,Source等新的事件就会放到新的自动释放池中，当RunLoop退出的时候也会被释放。

## block

> block的原理是怎样的？本质是什么？
> `__block` 的作用是什么？有什么使用注意点？
> block的属性修饰词为什么是copy？使用block有哪些使用注意？
> block在修改NSMutableArray，需不需要添加 `__block`？

```objc
struct __block_impl {
void *isa;//isa指针，所以说Block是对象
int Flags;
int Reserved;
void *FuncPtr;//函数指针
};
```

block内部有isa指针，所以说其本质也是OC对象;所以说 Block是将函数及其执行上下文封装起来的对象

1. __block_impl结构体中isa指针存储着&_NSConcreteStackBlock地址，可以暂时理解为其类对象地址，block就是_NSConcreteStackBlock类型的。
2. block代码块中的代码被封装成__main_block_func_0函数，FuncPtr则存储着__main_block_func_0函数的地址。
3. Desc指向__main_block_desc_0结构体对象，其中存储__main_block_impl_0结构体所占用的内存。

### 变量捕获

* 局部变量都会被block捕获，
* 自动变量是值捕获，
* 静态变量为地址捕获。
* 全局变量则不会被block捕获

### `__block`

__block将变量包装成对象，然后在把age封装在结构体里面，block内部存储的变量为结构体指针，也就可以通过指针找到内存地址进而修改变量的值。

## weak

* runtime如何实现weak变量的自动置nil？知道SideTable吗？
* 在 Runtime 中专门维护了一个用于存储 weak指针变量的 weak 表，这实际上是一个 Hash 表。这个表 key 是 weak指针 所指向的内存地址，value 是指向这个内存地址的所有 weak指针，实际上是一个数组。
1. 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。
2. 添加引用时：objc_initWeak函数会调用objc_storeWeak() 函数， objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。
3. 释放时,调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。

SideTable结构体是负责管理类的引用计数表和weak表，

### 弱引用容器

* 系统api ： NSPointerArray、NSMapTable、NSHashTable
* 在 iOS 中，NSValue 的类方法 valueWithNonretainedObject 可以保持对对象的弱引用。
* [block 来解除对对象的强引用](https://www.jianshu.com/p/09977bb95be0)

## Mach-O

Mach-O 文件包含了三部分内容：

* Header（头部），指明了 cpu 架构、大小端序、文件类型、Load Commands 个数等一些基本信息
* Load Commands（加载命令)
* LC_SEGMENT_64和LC_SEGMENT是加载的主要命令，它负责指导内核来设置进程的内存空间
* 1. __PAGEZERO: 空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用；
* 2. __TEXT: 包含了执行代码以及其他只读数据。该段数据的保护级别为：VM_PROT_READ（读）、VM_PROT_EXECUTE(执行)，防止在内存中被修改；
* 3. __DATA: 包含了程序数据，该段可写；
* 4. __LINKEDIT: 链接器使用的符号以及其他表
* Data（数据区），Segment 的具体数据，包含了代码和数据等。
* `__TEXT.__objc_methname   Objective-C 方法名称`
* `__TEXT.__objc_methtype   Objective-C 方法类型`
* `__TEXT.__objc_classname  Objective-C 类名称`
* `__DATA.__objc_classlist  Objective-C 类列表`
* `__DATA.__objc_protolist  Objective-C 原型`

## [React Native](http://blog.poetries.top/2019/10/02/rn-yuanli/)

* RCTRootView
	* RCTRootView继承自UIView, RCTRootView主要负责初始化JS Environment和React代码，然后管理整个运行环境的生命周期。
	* 创建并且持有RCTBridge
	* 加载JS Bundle并且初始化JS运行环境.
	* 初始化JS运行环境的时候在App里面显示loadingView,
	* JS运行环境准备好以后把加载视图用RCTRootContentView替换加载视图
	* 有准备工作就绪以后调用AppRegistry.runApplication正式启动RN JS代码，从Root Component()开始UI绘制
* RCTRootContentView
*  RCTBridge
* RCTBatchedBridge
	* 负责Native和JS之间的相互调用(消息通信)
* RCTModuleMethod
	* 记录所有原生代码的导出函数地址(JS里面是不能直接持有原生对象的)，同时生成对应的字符串映射到该函数地址。JS调用原生函数的时候会通过message的形式调用过来
	* 记录所有的原生代码的函数地址，并且生成对应的字符串映射到该地址
	* 记录所有的block的地址并且映射到唯一的一个id
	* 翻译所有J2N call，然后执行对应的native方法	
* MessageQueue
	* 这是核心中的核心。整个react native对浏览器内核是未做任何定制的，完全依赖浏览器内核的标准接口在运作。它怎么实现UI的完全定制的呢？它实际上未使用浏览器内核的任何UI绘制功能，注意是未使用UI绘制功能。它利用javascript引擎强大的DOM操作管理能力来管理所有UI节点，每次刷新前把所有节点信息更新完毕以后再给yoga做排版，然后再调用原生组件来绘制。javascript是整个系统的核心语言。
	* 我们可以把浏览器看成一个盒子，javascript引擎是盒子里面的总管，DOM是javascript引擎内置的，javascript和javascript引擎也是无缝链接的。react native是怎么跳出这个盒子去调用外部原生组件来绘制UI的呢？秘密就在MessageQueue。
	* javascript引擎对原生代码的调用都是通过一套固定的接口来实现，这套接口的主要作用就是记录原生接口的地址和对应的javascript的函数名称，然后在javascript调用该函数的时候把调用转发给原生接口
* 原生代码初始化
	* 这里讨论的主要是RN相关的原生代码和用户自定义的RN模块的原生代码的加载和初始化。原生代码初始化主要分两步
	* 静态加载。iOS没有动态加载原生代码的接口，所有的代码都在编译的初期就已经编译为静态代码并且链接好，程序启动的时候所有的原生代码都会加载好。这是原生代码的静态加载，iOS里面没有动态加载原生代码的概念，这也是为何没有静态代码热更新的原因
	* RN模块解析和注入JS。这是加载的第二步。在RootView初始化的时候会遍历所有被标记为RCTModule的原生模块，生成一个json格式的模块信息，里面包含模块名称和方法名称，然后注入到JS Engine, 由MessageQueue记录下来。原生代码在生成json模块信息的时候同时会在原生代码这边维护一个名称字典，用来把模块和方法的名称映射到原生代码的地址上去，用于JS调用原生代码的翻译
	* NativeModules加载
		* 在OC里面，所有NativeModules要加载进JS Engine都必须遵循一定的协议(protocol)。
		* 模块(OC里面的类)需要声明为, 然后在类里面还必须调用宏RCT_EXPORT_MODULE() 用来定义一个接口告诉JS当前模块叫什么名字。这个宏可以接受一个可选的参数，指定模块名，不指定的情况下就取类名。
		* 对应的JS模块在初始化的时候会调用原生类的[xxx new]方法- 模块声明为<RCTBridgeModule>后只是告诉Native Modules这有一个原生模块，是一个空的模块。要导出任何方法给JS使用都必须手动用宏RCT_EXPORT_METHOD来导出方法给JS用.
		* 所有的原生模块都会注册到NativeModules这一个JS模块下面去，你如果想要让自己的模块成为一个顶级模块就必须再写一个JS文件封装一遍NativeModules里面的方法。	

## [autoreleasePool](https://draveness.me/autoreleasepool/)


- 自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的
- 当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中
- 调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息
- autoreleasePool对象什么时候释放 [sunnyxx autoreleasePool](http://blog.sunnyxx.com/2014/10/15/behind-autorelease/)
    - 在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop

## 引用计数

> [iOS引用计数管理之揭秘计数存储](https://juejin.im/entry/5b4470e1e51d451951130c0c)

* 对象的引用计数到底存哪里了
    * 是Tagged Pointer对象 ? Tagged Pointer对象，并没有任何的引用计数操作，引用计数数量也只是单纯的返回自己地址罢了
    * 是否启用了Non-pointer ? isa的extra_rc变量进行+1
    * 储存在SideTable RefcountMap 中

> [Tagged Pointer](https://www.jianshu.com/p/3176e30c040b)

* 为了改进上面提到的内存占用和效率问题，苹果提出了Tagged Pointer对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节;
* 可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址
* Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate
* Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free。
* 在内存读取上有着 3 倍的效率，创建时比以前快 106 倍。

## 属性 

* [从一道网易面试题浅谈OC线程安全](https://www.jianshu.com/p/cec2a41aa0e7)