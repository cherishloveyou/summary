---
title:  iOS 大纲
date:  2019-08-07 20:53:38
---

# iOS

## 函数防抖和限流

[Objective-C Message Throttle and Debounce](http://yulingtianxia.com/blog/2017/11/05/Objective-C-Message-Throttle-and-Debounce/)

[MessageThrottle Performance Benchmark and Optimization](http://yulingtianxia.com/blog/2018/05/31/MessageThrottle-Performance-Benchmark-and-Optimization/)

## APM

* CPU 

## Runtime

### 消息发送转发

* OC 是一门动态语言，函数调用变成了消息发送，在编译期不能知道要调用哪个函数。所以 Runtime 无非就是去解决如何在运行时期找到调用方法这样的问题。
* 对于实例变量有如下的思路：instance -> class -> method -> SEL -> IMP -> 实现函数
* 实例对象中存放 isa 指针以及实例变量，有 isa 指针可以找到实例对象所属的类对象 (类也是对象，面向对象中一切都是对象)，类中存放着实例方法列表，在这个方法列表中 SEL 作为 key，IMP 作为 value。 整个 Runtime 的核心就是 objc_msgSend 函数，通过给类发送 SEL 以传递消息，找到匹配的 IMP 再获取最终的实现
	* 在编译时期，根据方法名字会生成一个唯一的 Int 标识，这个标识就是 SEL。
	* IMP 其实就是函数指针 指向了最终的函数实现。
* 当调用实例方法时，通过 isa 指针找到实例对应的 class 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy).
* 当调用类方法时，通过 isa 指针找到实例对应的 metaclass 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类
如下用于描述动态消息解析的流程:
* 动态消息调用
	* resolveInstanceMethod
	* forwardingTargetForSelector
	* methodSignatureForSelector + forwardInvocation

### 类结构

```objc
struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE; // 成员变量地址列表
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE; // 方法地址列表
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE; // 缓存最近使用的方法地址，以避免多次在方法地址列表中查询，提升效率
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE; // 遵循的协议列表
#endif

} OBJC2_UNAVAILABLE;
```

实例对象的 isa 指向类
类对象的 isa 指向元类
元类isa 指向根元类

### [对象占用内存](https://www.jianshu.com/p/b4552fef8683)

```objc
NSObject* smobj = [NSObject new];
NSLog(@"%zd",class_getInstanceSize([smobj class]));
NSLog(@"%zd",malloc_size((__bridge void*)smobj));
// 8 16 
```
```objc
@interface Sark : NSObject
@property (nonatomic,assign) int str;
@property (nonatomic,assign) int str2;
@property (nonatomic,assign) int str3;
@end

Sark* sark = [Sark new];

NSLog(@"%zd",class_getInstanceSize([sark class]));
NSLog(@"%zd",malloc_size((__bridge void*)sark));

//对象至少要16个字节
//int long float char 型 8 位？
//输出 24 32 
```

###  weak实现原理

* runtime如何实现weak变量的自动置nil？知道SideTable吗？
	* 在 Runtime 中专门维护了一个用于存储 weak指针变量的 weak 表，这实际上是一个 Hash 表。这个表 key 是 weak指针 所指向的内存地址，value 是指向这个内存地址的所有 weak指针，实际上是一个数组。
1. 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。
2. 添加引用时：objc_initWeak函数会调用objc_storeWeak() 函数， objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。
3. 释放时,调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。

SideTable结构体是负责管理类的引用计数表和weak表，



### 分类

>app初始化中 map_image

1)、把category的实例方法、协议以及属性添加到类上
2)、把category的类方法和协议添加到类的metaclass上

>添加属性

创建一个类的分类Category，并添加一个属性CategoryProperty，分类中的@CategoryProperty并没有帮我们生成实例变量以及存取方法，要求我们手动实现，这时候就需要用到对象关联。在分类中，因为类的实例变量的布局已经固定，使用 @property 已经无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量） 

* 关联对象其实就是 ObjcAssociation 对象
	* 关联对象由 AssociationsManager 管理并在 AssociationsHashMap 存储
	* 对象的指针以及其对应 ObjectAssociationMap 以键值对的形式存储在 AssociationsHashMap 中
	* ObjectAssociationMap 则是用于存储关联对象的数据结构
	* 每一个对象都有一个标记位 has_assoc 指示对象是否含有关联对象

### block

__block_impl结构体为
```
struct __block_impl {
  void *isa;//isa指针，所以说Block是对象
  int Flags;
  int Reserved;
  void *FuncPtr;//函数指针
};
```
block内部有isa指针，所以说其本质也是OC对象;所以说 Block是将函数及其执行上下文封装起来的对象

// 可以理解为copy了一个副本进入这个block，外部怎么变都和里面无关
  const charchar *ch;  
// 这就是重点，当你加了`__block` 内部转换就变成了结构体指针
// 你可以理解为加了修饰符，就变成了结构体，那这里就是拿到了引用
// 外部和内部引用的是同一个，外部修改就能改变内部 `__Block_byref_a_0 *a; `

1、局部变量截获 是值截获
```objc
    NSInteger num = 3;    
    NSInteger(^block)(NSInteger) = ^NSInteger(NSInteger n){        
        return n*num;
    };
    num = 1;
    NSLog(@"%zd",block(2));
//输出6	
```
2、局部静态变量截获
```objc
  static  NSInteger num = 3;    
    NSInteger(^block)(NSInteger) = ^NSInteger(NSInteger n){        
        return n*num;
    };    
    num = 1;    
    NSLog(@"%zd",block(2));
//输出2	
```
3、全局变量，静态全局变量截获

// 默认情况下, 任何block都是在栈, 随时可能会被回收
// 对block做一次copy操作,block的内存就会放到堆里面
【在ARC下】：似乎已经没有栈上的block了，要么是全局的，要么是堆上的。有一个特殊情况：如果仅仅定义了block没有赋值给变量的话，仍是在栈上,比如：
【在非ARC下】：存在这栈、全局、堆这三种形式。

### checklist

#### +load | +initialize

* +load 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。
* +initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 +initialize 方法是以懒加载的方式被调用的
	* 如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。
	* 因此，如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。




#### 相关API 场景

* 模型转字典的时候：
	* 调用 class_copyPropertyList 方法获取当前 Model 的所有属性.
	* 调用 property_getName 获取属性名称.
	* 根据属性名称生成 getter 方法.
	* 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）
* 对象关联
	* 要取出被关联的对象使用 objc_getAssociatedObject 方法即可，
	* 要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可
	* objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.
* 遍历变量
	* 使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.
	* 使用 ivar_getName 方法获取成员变量的名称.
	* 通过 KVC 来读取 Model 的属性值	
* 遍历方法
	* 使用 class_copyMethodList 方法获取当前 Model 的所有成员变量.
	* 使用 method_getName 方法获取成员变量的名称.	
* 动态交换方法
	* Method class_getInstanceMethod(Class cls, SEL name) 找到方法实例
	* void method_exchangeImplementations(Method m1, Method m2) 交换方法
	* 利用 class_replaceMethod 来修改类，
	* 利用 method_setImplementation 来直接设置某个方法的IMP
* 动态添加方法
	* void class_addMethods(Class, struct objc_method_list *)添加多个方法
	* BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)添加方法
* 遍历协议
	* 使用 class_copyProtocolList 方法获取当前 Model 的所有成员变量.
	* 使用 protocol_getName 方法获取成员变量的名称.
* 动态创建对象
	* Class People = objc_allocateClassPair([NSObject class], "Person", 0);


#### self class vs super class


```objc
@implementation Son : Father
- (id)init {
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
//输出 Son Son
```

```objc
@interface Father : NSObject
@end

@implementation Father

- (Class)class {
    return [Father class];
}

@end

---

@interface Son : Father
@end

@implementation Son

- (id)init {
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}

@end

int main(int argc, const char * argv[]) {
    Son *foo = [[Son alloc]init];
    return 0;
}

//输出 Father Father
```

####  使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？

```
被关联的对象在生命周期内要比对象本身释放的晚很多，它们会在被 NSObject -dealloc 调用的object_dispose()方法中释放。
```
- runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）
	- 每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.
-  能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？
	- 不能向编译后得到的类中增加实例变量；
	- 能向运行时创建的类中添加实例变量；
	- 因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；
	- 运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。	
- 实例对象的数据结构 类对象的数据结构
	- 实例对象 objc_object 私有属性只有一个 isa 指针。指向 类对象 的内存地址 ；类对象就是 objc_class ； 

<!-- more -->

## 内存

- 内存泄露场景、检测方式
	- [PLeakSniffer](http://mrpeak.cn/blog/leak/)
	- [MLeaksFinder](http://wereadteam.github.io/2016/02/22/MLeaksFinder/)
	- [IOS内存泄漏检测方式和泄漏场景](https://www.jianshu.com/p/e9d989c12ff8)

### 内存管理方案

* taggedPointer ：存储小对象如NSNumber。深入理解Tagged Pointer
* NONPOINTER_ISA(非指针型的isa):在64位架构下，isa指针是占64比特位的，实际上只有30多位就已经够用了，为了提高利用率，剩余的比特位存储了内存管理的相关数据内容。
* 散列表：复杂的数据结构，包括了引用计数表和弱引用表
通过SideTables()结构来实现的，SideTables()结构下，有很多SideTable的数据结构。
而sideTable当中包含了自旋锁，引用计数表，弱引用表。
SideTables()实际上是一个哈希表，通过对象的地址来计算该对象的引用计数在哪个sideTable中。

### AutoreleasePool

release只是把对象引用计数-1。autorelease实际上只是把release延迟调用了【autorelease会在对象真正使用结束时候才做引用计数-1】，系统只是把对象放入了autoreleasepool中，当pool释放时，该pool中所有对象就会被调用release

- App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。
- 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。
- 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。
- 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。

### 循环引用

- 场景 父类与子类 delegate block  NSTimer
- weakSelf & strongSelf
	- weakSelf的缺陷，可能会导致内存提前回收。
	- 内部的strongSelf仅仅是个局部变量，存在栈中，会在block执行结束后回收，不会再造成循环引用。
	- 这么做和使用weakSelf有什么区别：唯一的区别就是多了一个strongSelf，而这里的strongSelf会使ClassB的对象引用计数＋1，使得ClassB pop到A的时候，并不会执行dealloc，因为引用计数还不为0，strongSelf仍持有ClassB，而在block执行完，局部的strongSelf才会回收，此时ClassB dealloc。
- 解决 NSTimer循环引用
	- 分类 block 传入weakself
	- 中间件
- 循环引用检测
	- instrument delloc [MLeaksFinder](https://wereadteam.github.io/2016/02/22/MLeaksFinder/)	

#### timer 转发

```objc
__weak typeof(self) weakSelf = self;
self.myBlock = ^() {
        __strong __typeof(self) strongSelf = weakSelf;
        [strongSelf test];
 };
```

```objc
@interface ZYWeakObject()
@property (weak, nonatomic) id weakObject;
@end
@implementation ZYWeakObject
- (instancetype)initWithWeakObject:(id)obj {
    _weakObject = obj;
    return self;
}
+ (instancetype)proxyWithWeakObject:(id)obj {
    return [[ZYWeakObject alloc] initWithWeakObject:obj];
}

//消息转发，让_weakObject响应事件
 
- (id)forwardingTargetForSelector:(SEL)aSelector {
    return _weakObject;
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    void *null = NULL;
    [invocation setReturnValue:&null];
}

- (BOOL)respondsToSelector:(SEL)aSelector {
    return [_weakObject respondsToSelector:aSelector];
}

//使用
// target要设置成weakObj，实际响应事件的是self
ZYWeakObject *weakObj = [ZYWeakObject proxyWithWeakObject:self];
self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakObj selector:@selector(changeText) userInfo:nil repeats:YES];

```

### checklist

#### 内存中的5大区分别是什么？

栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其 操作方式类似于数据结构中的栈。
堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放。
文字常量区：常量字符串就是放在这里的。 程序结束后由系统释放。
程序代码区：存放函数体的二进制代码。


#### 栈 与 堆

* 栈： 是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中。
* 堆 ：是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用malloc和free时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生memory leak。用链表来存储的空闲内存地址的，自然是不连续的。
* .data： 初始化了的全局变量和静态变量
* .bss： 即 Block Started by Symbol， 未初始化的全局变量和静态变量（这个我感觉上课真的没讲过啊我去。。。）
* 栈里面存放的是非对象的基本数据类型，堆内存存放着oc对象

#### 简要说一下 @autoreleasePool 的数据结构？

简单说是双向链表，每张链表头尾相接，有 parent、child指针

每创建一个池子，会在首部创建一个 哨兵 对象,作为标记

最外层池子的顶端会有一个next指针。当链表容量满了，就会在链表的顶端，并指向下一张表。

#### ARC 在运行时做了哪些工作？

主要是指 weak 关键字。weak 修饰的变量能够在引用计数为0 时被自动设置成 nil，显然是有运行时逻辑在工作的。

为了保证向后兼容性，ARC 在运行时检测到类函数中的 autorelease 后紧跟其后 retain，此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue。
objc_autoreleaseReturnValue 会检视当前方法返回之后即将要执行的那段代码，若那段代码要在返回对象上执行 retain 操作，则设置全局数据结构中的一个标志位，而不执行 autorelease 操作，与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain ，而是改为执行 objc_retainAoutoreleasedReturnValue函数。此函数要检测刚才提到的标志位，若已经置位，则不执行 retain 操作，设置并检测标志位，要比调用 autorelease 和retain更快。

#### ARC 在编译时做了哪些工作

根据代码执行的上下文语境，在适当的位置插入 retain，release



#### 悬垂指针？什么是 野指针?

悬垂指针
指针指向的内存已经被释放了，但是指针还存在，这就是一个 悬垂指针 或者说 迷途指针

野指针
没有进行初始化的指针，其实都是 野指针

#### 深拷贝

集合深复制的方法，有两种：

```objc
//使用initWithArray:copyItems:方法，将第二个参数设置为YES即可

NSDictionary shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:YES];

//将集合对象进行归档（archive）然后解归档（unarchive）：

NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];
```

## Mach-O

### 编译过程

* 预处理阶段：符号化、宏定义展开头文件展开
* 语法和语义分析阶段：将符号化后的内容转化为一棵解析树、解析树做语义分析 输出一棵抽象语法树
* 生成代码和优化阶段：将 AST 转换为更低级的中间码 (LLVM IR)、对生成的中间码做优化、生成特定目标代码、输出汇编代码
* 汇编器阶段：将汇编代码转换为目标对象文件。
* 链接器：将多个目标对象文件合并为一个可执行文件 (或者一个动态库)



### Clang

- 开发clang插件
	- [clang 插件示例](https://www.jianshu.com/p/4935e919bb45)
	- [clang 插件示例](https://www.itcodemonkey.com/article/7459.html)
	- [clang 插件示例](https://kangwang1988.github.io/tech/2016/10/31/write-your-first-clang-plugin.html)	
- clang扫描无用代码
	- [clang扫描无用代码](https://blog.gocy.tech/2017/09/12/DetectingUselessCodeWithClang-p1/)
	- [clang代码级别瘦身](https://www.infoq.cn/article/clang-plugin-ios-app-size-reducing)
	- 局限性
		- NSObject 协议的 performSelector 方法簇
		- 手势 / 按钮的事件处理 selector addTarget:action:/initWithTarget:action:/addTarget:action:forControlEvents
		- NSNotificationCener 添加通知处理 Selector addObserver:selector:name:object:
		- Timer scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: /timerW
		- NSThread detachNewThreadSelector:toTarget:withObject:/initWithTarget:selector:object:
		- CADisplayLink displayLinkWithTarget:selector:
		- [XXX new] 包含+[XXX alloc]和-[XXX init]
		- openUrl 机制 假设工程设置里使用了openUrl:"XXX://XXViewController"来打开一个 VC，则 Clang 插件里面需要分析 openUrl 的参数，如果参数是 XXViewController，则暗含了+[XXViewController alloc]和-[XXViewController init].
		- Model 转化 如如果 MTLModel 使用到了modelOfClass:[XXXModel class] fromJSONDictionary:error:，则暗含了+[XXXModel alloc]和+[XXXModel init]- - - Message swizzle 假设用户 swizzle 了-[UIViewController viewDidLoad]和-[UIViewController XXviewDidLoad]，则需要在 implicitCallStackJson 中添加-[UIViewController XXviewDidLoad],-[UIViewController viewDidLoad].
		- 第三方 Framework 暗含的逻辑 如高德地图的 AnnotationView, 需要 implicitCallStackJson 中添加"-[MAAnnotationView prepareForReuse:]","+[MAAnnotationView alloc]"等。包括第三方 Framework 里面的一些 Protocol，可能也需要参考前文提到的 UIApplicationDelegate 按照系统级别的 Protocol 来处理。
		- 一些遗漏的重载方法 如-[XXDerivedManager sharedInstance]并无实现，而 XXDerivedManager 的基类 XXBaseManager 的 sharedInstance 调用了-[self alloc], 但因为 self 静态分析时被认定为 XXBaseManager，这就导致-[XXDerivedManager sharedManager]虽然被 usedclsmethod.json 调用，但是-[XXDerivedManager alloc]却不能被调用。这种情况，可以在 usedClsMethodJson 初始化的时候，加入"+[XXDerivedManager alloc]","-[UIApplication main]"。- 类似 Cell Class 我们常会使用动态的方法去使用[[[XXX cellClassWithCellModel:] alloc] initWithStyle:reuseIdentifier:]去构造 Cell，这种情况下，应该针对cellClassWithCellModel里面会包含的各种return [XXXCell class]，在 implicitCallStackJson 中添加[[XXXCell alloc] initWithStyle:reuseIdentifier:],-[XXX cellClassWithCellModel:]这种调用。
		- Xib/Storyboard 会暗含一些 UI 元素 (Controller,Table,Button,Cell,View 等) 的 alloc 方法或调用关系。
		- 其他隐含的逻辑或者动态特性导致的调用关系遗漏
- clang AST [clang AST](https://www.stephenw.cc/2018/01/08/clang-ast/)


## runloop

### RunLoop的数据结构

NSRunLoop(Foundation)是CFRunLoop(CoreFoundation)的封装，提供了面向对象的API
RunLoop 相关的主要涉及五个类：

CFRunLoop：RunLoop对象
CFRunLoopMode：运行模式
CFRunLoopSource：输入源/事件源
CFRunLoopTimer：定时源
CFRunLoopObserver：观察者

### runloop 与 线程的关系

- 一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。Runloops 是线程的基础架构部分，Cocoa和CoreFundation都提供了 runloop对象方便配置和管理线程的 runloop（以下都已Cocoa为例）。每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。
- 主线程的run loop默认是启动的 UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象
- 对其它线程来说，run loop默认是没有启动的
- 在任何一个Cocoa程序的线程中，都可以通过：`NSRunLoop   *runloop = [NSRunLoopcurrentRunLoop]`;
- Run loop同时也负责autorelease pool的创建和释放

### NSPort

- source0指的是非基于端口por，说白了也就是处理触摸事件，selector事件 ； source1指的是基于端口的port：是处理系统的一些事件 ； timer

### NSTimer 与 CADisplay

解释一下 NSTimer。
NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。

如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。

CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。

### runloop Observer 几个阶段

- 即将进入 ； 将处理timer ; 将处理source0 ； 处理source0 ; 有source1跳到第九步 ; 线程将休眠 ； 休眠 ； 刚被唤醒 ； 处理消息跳到2 ； 即将退出


### 事件响应

当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。

_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。


### 手势识别

当上面的 _UIApplicationHandleEventQueue()识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。

苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer 的回调。

当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。

### 界面更新、 页面的渲染的过程

- 当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。
- 苹果注册了一个 Observer 监听 ***BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop)*** 事件，回调去执行一个很长的函数：
- 这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面 	
- 紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer 层会判断自己的 delegate 有没有实现异步绘制的代理方法 displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，那么会继续进行系统绘制的流程，然后绘制结束。
- CALayer 内部会创建一个 Backing Store，用来获取图形上下文。接下来会判断这个 layer 是否有 delegate。
- 如果有的话，会调用 [layer.delegate drawLayer:inContext:]，并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。
	
### runloop的mode作用是什么？

- 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。
- mode 主要是用来指定事件在运行循环中的优先级的，分为：
	- NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态
	- UITrackingRunLoopMode：ScrollView滑动时
	- UIInitializationRunLoopMode：启动时
	- NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合
	- 苹果公开提供的 Mode 有两个：
		- NSDefaultRunLoopMode（kCFRunLoopDefaultMode）
		- NSRunLoopCommonModes（kCFRunLoopCommonModes）	


### 关于GCD 与 runloop

- 实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。
- 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 `__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()` 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。

### NSThread+runloop实现常驻线程

1、为当前线程开启一个RunLoop（第一次调用 [NSRunLoop currentRunLoop]方法时实际是会先去创建一个RunLoop）
2、向当前RunLoop中添加一个Port/Source等维持RunLoop的事件循环（如果RunLoop的mode中一个item都没有，RunLoop会退出）
3、启动该RunLoop


```objc
+ (NSThread *)shareThread {
    
    static NSThread *shareThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&oncePredicate, ^{
        
        shareThread = [[NSThread alloc] initWithTarget:self selector:@selector(threadTest2) object:nil];
        [shareThread setName:@"threadTest"];
        [shareThread start];
    });
    return shareThread;
}

+ (void)threadTest
{
    @autoreleasepool {        
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];        
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];        
        [runLoop run];
    }
}
```

## 多线程/锁

* 有 A B C D 四个任务，他们分别工作在不同的线程中，使用信号量，使得 A B C 完成之后D 任务才能执行
* 3.多线程实现方式，如何保证线程安全
* 4.有几种锁
* [从一道网易面试题浅谈OC线程安全](https://www.jianshu.com/p/cec2a41aa0e7)


### PerformSelector 的实现原理？

当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。

当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。


### 多线程实现

Pthreads NSThread GCD NSOperation & NSOperationQueue

### GCD

* GCD的队列 串行队列 并行队列
* dispatch_group_notify dispatch_group_wait
* dispatch_once  dispatch_block_cancel
* dispatch_suspend dispatch_resume
* dispatch_barrier_async会把并行队列的运行周期分为这三个过程：
	* 首先等目前追加到并行队列中所有任务都执行完成
	* 开始执行dispatch_barrier_async中的任务，这时候即使向并行队列提交任务，也不会执行
	* dispatch_barrier_async中的任务执行完成后，并行队列恢复正常
* dispatch_semaphore 信号量为0时需要等待，信号量不为零时，减去1而且不等待。

### [GCD实现原理](https://bestswifter.com/deep-gcd/)

<img src="/res/tmp/gcd-pool.png" width="50%"/>

* 异步：
	* 队列其实就是一个用来提交 block 的对象，当 block 提交到队列中后，将按照 “先入先出(FIFO)” 的顺序进行处理。系统在 GCD 的底层会维护一个线程池，用来执行这些 block ;
	* 用链表保存所有提交的 block，然后在底层线程池中，依次取出 block 并执行。
* 同步：信号量，保证了每次只有一个 block 被执行。

### GCD VS NSOperationQueue

1. GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便
2. GCD只支持FIFO的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序
3. NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂
4. NSOperationQueue因为面向对象，所以支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）

### GCD 执行顺序

```objc
    dispatch_queue_t serialQueue = dispatch_queue_create("test", DISPATCH_QUEUE_SERIAL);
     NSLog(@"1");     
     dispatch_async(serialQueue, ^{         
          NSLog(@"2");
     });     
     NSLog(@"3");     
     dispatch_sync(serialQueue, ^{         
         NSLog(@"4");
     });     
     NSLog(@"5");
//输出13245	 
```

### 死锁

一个比较常见的死锁例子:主队列同步

```objc
- (void)viewDidLoad {
    [super viewDidLoad];
    
    dispatch_sync(dispatch_get_main_queue(), ^{
       
        NSLog(@"deallock");
    });
    // Do any additional setup after loading the view, typically from a nib.
}
```

### dispatch_barrier_async 多读单写

```objc
- (id)readDataForKey:(NSString *)key
{
    __block id result;    
    dispatch_sync(_concurrentQueue, ^{       
        result = [self valueForKey:key];
    });    
    return result;
}

- (void)writeData:(id)data forKey:(NSString *)key
{
    dispatch_barrier_async(_concurrentQueue, ^{       
        [self setValue:data forKey:key];
    });
}
```

### 信号量保持线程同步

```objc

dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);        
__block NSInteger number = 0;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
	number = 100;
	dispatch_semaphore_signal(semaphore);
});
    
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
NSLog(@"semaphore---end,number = %zd",number);

```

### dispatch_after 延迟

dispatch_after能让我们添加进队列的任务延时执行，该函数并不是在指定时间后执行处理，而只是在指定时间追加处理到dispatch_queue
```objc
//第一个参数是time，第二个参数是dispatch_queue，第三个参数是要执行的block
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        
        NSLog(@"dispatch_after");
    });
```

由于其内部使用的是dispatch_time_t管理时间，而不是NSTimer。
所以如果在子线程中调用，相比performSelector:afterDelay,不用关心runloop是否开启

### GCD单例

```objc
+ (instancetype)shareInstance {
    static dispatch_once_t onceToken;
    static id instance = nil;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}
```


### 进程间通信 和 线程间同步 锁

共享内存(shared memory)：套接字(socket) ：


线程间同步主要有以下几种方式：[锁](https://juejin.im/post/57f6e9f85bbb50005b126e5f)

* 互斥量（mutex）： NSLock  synchronized  pthread_mutex
	* 是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。
* 读写锁（rwlock）：读操作可并发重入，写操作是互斥的。  pthread_rwlock
* 递归锁 ：同一个线程可以加锁N次而不会引发死锁。 NSRecursiveLock	pthread_mutex（recursive）
* 条件变量（cond）：就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。 NSCondition NSConditionLock
* 信号量（semophore）：  dispatch_semaphore
* 自旋锁（spinlock）：等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源  os_unfair_lock OSSpinLock


### 线程进程

* 一、 进程：
	1. 进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元.
	2. 进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app.
	3. 每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源
* 二、 线程
	1. 程序执行流的最小单元，线程是进程中的一个实体.
	2. 一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程
* 三、 进程和线程的关系
	1. 线程是进程的执行单元，进程的所有任务都在线程中执行
	2. 线程是 CPU 分配资源和调度的最小单位
	3. 一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程
	4. 同一个进程内的线程共享进程资源

### 异步转同步

```objc

    NSLock *lockA = [[NSLock alloc] init];
    NSLock *lockB = [[NSLock alloc] init];
    NSLock *lockC = [[NSLock alloc] init];
    
    [lockB lock];
    [lockC lock];
    
    dispatch_queue_t queueA = dispatch_queue_create("queuea", DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queueA, ^{
        for (int i = 0; i<10; i++) {
            [lockA lock];
            NSLog(@"A======= %@",@(i));
            [lockB unlock];
        }
    });
    
    dispatch_queue_t queueB = dispatch_queue_create("queueb", DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queueB, ^{
        for (int i = 0; i<10; i++) {
            [lockB lock];
             NSLog(@"B======= %@",@(i));
            [lockC unlock];
        }
    });
    
    dispatch_queue_t queueC = dispatch_queue_create("queuec", DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queueC, ^{
        for (int i = 0; i<10; i++) {
            [lockC lock];
             NSLog(@"C======= %@",@(i));
             NSLog(@"   ");
            [lockA unlock];
        }
    });

```



- [source0 + 事件传递](https://zhuanlan.zhihu.com/p/56441355)
- [runloop总结](https://www.jianshu.com/p/d260d18dd551)
- [runloop + 其他关联](http://www.cocoachina.com/articles/11970#header)
- [runloop + 其他关联 nstimer](https://www.cnblogs.com/kenshincui/p/6823841.html)



## Foundation

### 类簇

#### isKindOfClass isMemberOfClass

```objc
@interface Sark : NSObject
@end
@implementation Sark
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // insert code here...

        NSLog(@"%@", [NSObject class]);
        NSLog(@"%@", [Sark class]);

        BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];
        BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];
        BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];
        BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]];
        NSLog(@"%d--%d--%d--%d", res1, res2, res3, res4);
    }
    return 0;
}
//输出 1-0-0-0
```

```objc
    NSArray *myArr = [[NSArray alloc] init];
    NSMutableArray *myArr2 = [[NSMutableArray alloc] init];
    if ([myArr isKindOfClass:[NSArray class]]) {
        NSLog(@"myArr isKindOfClass of NSArray");
    }
    if ([myArr isMemberOfClass:[NSArray class]]) {
        NSLog(@"myArr isMemberOfClass of NSArray");
    }
    if ([myArr2 isKindOfClass:[NSMutableArray class]]) {
        NSLog(@"myArr2 isKindOfClass of NSMutableArray");
    }
    if ([myArr2 isMemberOfClass:[NSMutableArray class]]) {
        NSLog(@"myArr2 isMemberOfClass of NSMutableArray");
    }
//输出
// myArr isKindOfClass of NSArray
//myArr2 isKindOfClass of NSMutableArray    

/*
NSArray、NSMutableArray属于类簇，使用isMemberOfClass不能得到正确的结果
原因：由于类簇的性质，这类对象实际返回的实例有不确定性
NSArray对象可能会在运行时发现其实运作的是NSCFArray(来自Core Foundation框架(C语言的实现版本)，很多Cocoa对象都是如此做桥接的)
对于类簇的判断要谨慎
*/
```

#### NSArray class 类型

发现通过alloc之后都生成了__NSPlaceholderArray。后面的init都是把消息发送给了这个中间对象。再由它做工厂，生成真的对象。

所以总结一下就是：__NSArrayI是NSArray的真正类型 ,__NSArrayM是NSMutableArray真正类型。

__NSPlaceholderArray  __NSArray0  __NSArrayM

1、当元素为空时，返回的是__NSArray0的单例；
2、当元素仅有一个时，返回的是__NSSingleObjectArrayI的实例；
3、当元素大于一个的时候，返回的是__NSArrayI的实例;

__NSFrozenArrayM

## UI

### UI优化

[iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)

* CPU
	* 对象的创建调整销毁 （CALayer storyboard 视图层级移动 添加移除 大对象 autoreleasepool）
	* 布局计算 autolayout
	* 文本 宽高计算 富文本绘制 (coretext 
		* `[NSAttributedString boundingRectWithSize:options:context:]` 
		* `[NSAttributedString drawWithRect:options:context:]`
	* 图像的解码 绘制
		* 图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片 ,CoreGraphic
		* 图片是否被缩放，以及像素是否对齐
* GPU
	* 纹理的渲染
		* 图片不要超过最大纹理
		* Apple 的 GPU值解析32bit的颜色格式，RGBA
		* display p3 只在iOS9以上
	* 视图的混合 （透明度
	* 图形的生成 （border、圆角、阴影、遮罩	
* 应用
	* 把一个大的层级，通过一个大的绘制方法绘制到一张图
	* Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。
	* 预布局 预渲染

### [UITableView 复用原理](https://xiaozhuanlan.com/topic/0286491573)

```objc
- (id)initWithFrame:(CGRect)frame style:(UITableViewStyle)theStyle {
    if ((self=[super initWithFrame:frame])) {
        // 确定 TableView 的 Style
        _style = theStyle;
        // 要点一：Cell 缓存字典
        _cachedCells = [[NSMutableDictionary alloc] init];
        // 要点二：Section 缓存 Mutable Array
        _sections = [[NSMutableArray alloc] init];
        // 要点三：复用 Cell Mutable Set
        _reusableCells = [[NSMutableSet alloc] init];

        // 一些关于 Table View 的属性设置
        self.separatorColor = [UIColor colorWithRed:.88f green:.88f blue:.88f alpha:1];
        self.separatorStyle = UITableViewCellSeparatorStyleSingleLine;
        self.showsHorizontalScrollIndicator = NO;
        self.allowsSelection = YES;
        self.allowsSelectionDuringEditing = NO;
        self.sectionHeaderHeight = self.sectionFooterHeight = 22;
        self.alwaysBounceVertical = YES;

        if (_style == UITableViewStylePlain) {
            self.backgroundColor = [UIColor whiteColor];
        }
        // 加入 Layout 标记，进行手动触发布局设置
        [self _setNeedsReload];
    }
    return self;
}
```

我们要关注三个存储容器的变化情况：

* NSMutableDictionary 类型 `_cachedCells`：用来存储当前屏幕上所有 Cell 与其对应的 indexPath。以键值对的关系进行存储。
* NSMutableDictionary 类型 `availableCells`：当列表发生滑动的时候，部分 Cell 从屏幕移出，这个容器会对 _cachedCells 进行拷贝，然后将屏幕上此时的 Cell 全部去除。即最终取出所有退出屏幕的 Cell。
* NSMutableSet 类型 `_reusableCells`：用来收集曾经出现过此时未出现在屏幕上的 Cell。当再出滑入主屏幕时，则直接使用其中的对象根据 CGRectIntersectsRect Rect 碰撞试验进行复用。

`_setNeedsReload` : 
	首先先对 _needsReload 进行标记，之后调用了 setNeedsLayout 方法。对于 UIView 的 setNeedsLayout 方法，在调用后 Runloop 会在即将到来的周期中来检测 displayIfNeeded 标记，如果为 YES 则会进行 drawRect 视图重绘。作为 Apple UIKit 层中的基础 Class，在属性变化后都会进行一次视图重绘的过程。

```objc
- (void)reloadData {
    // 清除之前的缓存并删除 Cell
    // makeObjectsPerformSelector 方法值都进行调用某个方法
    [[_cachedCells allValues] makeObjectsPerformSelector:@selector(removeFromSuperview)];
    // 复用 Cell Set 也进行删除操作
    [_reusableCells makeObjectsPerformSelector:@selector(removeFromSuperview)];
    [_reusableCells removeAllObjects];
    [_cachedCells removeAllObjects];

    // 删除选择的 Cell
    _selectedRow = nil;
    // 删除被高亮的 Cell
    _highlightedRow = nil;

    // 更新缓存中状态
    [self _updateSectionsCache];
    // 设置 Size
    [self _setContentSize];

    _needsReload = NO;
}
```

当 reloadData 方法被触发时，UITableView 默认为在这个 UITableView 中的数据将会全部发生变化。测试之前遗留下的缓存列表以及复用列表全部都丧失了利用性。为了避免出现悬挂指针的情况（有可能某个 cell 被其他的视图进行了引用），我们需要对每个 cell 进行 removeFromSuperview 处理，这个处理即针对于容器 UITableView，又对其他的引用做出保障。然后我们更新当前 tableView 中的两个缓存容器，_reusableCells 和 _cachedCells，以及其他需要重置的成员属性。

### 事件响应

事件处理
UIView 是 UIResponder 的子类，可以响应触控事件。

通常可以使用 addGestureRecognizer: 添加手势识别器来响应触控事件，如果需要手动处理，则按需要重载 UIView 中的下面四个函数：

touchesBegan:withEvent:
touchesMoved:withEvent:
touchesEnded:withEvent:
touchesCancelled:withEvent:

>[hit test](https://zhoon.github.io/ios/2015/04/12/ios-event.html)

1. 设备将touch到的UITouch和UIEvent对象打包, 放到当前活动的Application的事件队列中
2. 单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow
3. UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view


递归是向界面的根节点UIWindow发送hitTest:withEvent:消息开始的，从这个消息返回的是一个UIView，也就是手指当前位置最前面的那个 hittest view。 当向UIWindow发送hitTest:withEvent:消息时，hitTest:withEvent:里面所做的事，就是判断当前的点击位置是否在window里面，如果在则遍历window的subview然后依次对subview发送hitTest:withEvent:消息

注意这里是怎么把事件传递给nextResponder的呢？拿touch事件来说，UIResponder里面touch四个阶段的方法里面，实际上是什么事都没有做的，UIView继承了它进行重写，重写的内容也是没有什么东西，就是把事件传递给nextResponder，比如：[self.nextResponder touchesBegan:touches withEvent:event]。

>增加点击区域

继承 UIButton 然后重写 pointInside:(CGPoint)point withEvent:(UIEvent *)event 方法

```objc
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {
    CGRect bounds = self.bounds;
    // 若原热区小于44x44，则放大热区，否则保持原大小不变
    CGFloat deltaW = MAX(44 - bounds.size.width, 0);
    CGFloat deltaH = MAX(44 - bounds.size.height, 0);
    bounds = CGRectInset(bounds, -deltaW * 0.5, -deltaH * 0.5);
    return CGRectContainsPoint(bounds, point);
}
```
### 核心动画core animation

* CALayer中很多属性都可以通过CAAnimation实现动画效果，包括：opacity、position、transform、bounds、contents等(可以在API文档中搜索：CALayer Animatable Properties)。
	* 通过调用CALayer的addAnimation:forKey增加动画到层(CALayer)中，这样就能触发动画了。通过调用removeAnimationForKey可以停止层中的动画。
* CApropertyAnimation的子类，可以创造帧动画。跟CABasicAnimation的区别是：CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值。
* CAAnimation的子类，用于做转场动画，比如翻书动画。它能够为层提供移出屏幕和移入屏幕的动画效果

* cashaperlayer catextlayer

### checklist

#### CALayer 的 Contents 有几下几个主要的属性：

* ContentsRect 单位制（0 - 1），限制显示的范围区域
* ContentGravity 类似于 ContentMode，不过不是枚举值，而是字符串
* ContentsScale 决定了物理显示屏是 几@X屏
* ContentsCenter 跟拉伸有关的属性

#### drawRect

UIView 是按需绘制的，当整个视图或者视图的一部分由于布局变化，变成可见的，系统会要求视图进行绘制。对于那些需要使用 UIKit 或者 CoreGraphics 进行自定义绘制的视图，系统会调用 drawRect: 方法进行绘制。

当视图内容发生变化时，需要调用 setNeedsDisplay 或者 setNeedsDisplayInRect: 方法，告诉系统该重新绘制这个视图了。调用这个方法之后，系统会在下一个绘制周期更新这个视图的内容。由于系统要等到下一个绘制周期才真正进行绘制，可以一次性对多个视图调用 setNeedsDisplay，它们会同时被更新

drawRect方法依赖Core Graphics框架来进行自定义的绘制,但这种方法主要的缺点就是它处理touch事件的方式: 每次按钮被点击后,都会用setNeddsDisplay进行强制重绘;而且不止一次,每次单点事件触发两次执行。这样的话从性能的角度来说,对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例。

#### UIView CALayer

> UIView 与 CALayer的关系

1. 首先UIView可以响应事件，Layer不可以.
	* UIKit使用UIResponder作为响应对象，来响应系统传递过来的事件并进行处理。在 UIResponder中定义了处理各种事件和事件传递的接口。
	* UIApplication、UIViewController、UIView、和所有从UIView派生出来的UIKit类（包括UIWindow）都直接或间接地继承自UIResponder类。
	* CALayer直接继承 NSObject，并没有相应的处理事件的接口。
2. UIView是CALayer的delegate
3. UIView主要处理事件，CALayer负责绘制就更好
4. 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint
* UIView的layer树形在系统内部被系统维护着三份copy
	* 逻辑树：就是代码里可以操纵的，例如更改layer的属性（阴影，圆角等）就在这一份
	* presentationLayer 动画树：这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作
	* 显示树：这棵树的内容是当前正被显示在屏幕上的内容

> frame 和 bounds

- frame的位置是根据父容器来计算的，正方形在动画开始前的x=100,y=100是相对于self.view的坐标系统而言的，从而确定当前视图在父视图中的位置。
- bounds的x,y是根据自己的坐标系统而言的。没错，每个view都有自己的坐标系。以自己左上角点为坐标原点。所以bounds的x,y默认为(0,0),除非调用setBounds方法；
- frame的size不一定等于bounds的size，在旋转后它们的size就不一样了。

#### [Application生命周期](https://www.cnblogs.com/chenyg32/p/3873301.html)

1. application:didFinishLaunchingWithOptions:
	* 程序首次已经完成启动时执行，若直接启动，launchOptions中没有数据；否则，launchOptions将包含对应方式的内容（比如从微信中启动节奏大师--）。
2. applicationWillResignActive（将进入后台）
	* 程序将要失去Active状态时调用，比如按下Home键或有电话信息进来。对应applicationWillEnterForeground（将进入前台），这个方法用来
	* 暂停正在执行的任务；禁止计时器；减少OpenGL ES帧率；若为游戏应暂停游戏；总结为一个字：停！
3. applicationDidEnterBackground（已经进入后台）
	* 程序已经进入后台时调用，对应applicationDidBecomeActive（已经变成前台），这个方法用来
	* 释放共享资源；保存用户数据（写到硬盘）；作废计时器；保存足够的程序状态以便下次恢复；总结为4个字：释放、保存！
4. applicationWillEnterForeground（将进入前台）
	* 程序即将进去前台时调用，对应applicationWillResignActive（将进入后台）。这个方法用来撤销applicationWillResignActive中做的改变。
5. applicationDidBecomeActive（已经进入前台）
	* 程序已经变为Active（前台）时调用。对应applicationDidEnterBackground（已经进入后台）。若程序之前在后台，最后在此方法内刷新用户界面。
6. applicationWillTerminate
	* 程序即将退出时调用。记得保存数据，如applicationDidEnterBackground方法一样。

#### UIViewController

> [loadView](https://blog.csdn.net/q199109106q/article/details/8614044)

* 每次访问UIViewController的view(比如controller.view、self.view)而且view为nil，loadView方法就会被调用。
* loadView方法是用来负责创建UIViewController的view
* 它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view
* 如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性

```objc
- (UIView *)view {
	if (!_view) {
		[self loadView];
		[self viewDidLoad]; // Edit: 这句话移动到括号内，感谢@change2hao的提醒
		}
	}
```

> [生命周期](https://www.jianshu.com/p/e0a3909fb3cc)

ViewController的生命周期中各方法扫行须序如下：

* init—>
* loadView—>
* viewDidLoad—>
* viewWillAppear—>
* viewWillLayoutSubviews()
* viewDidLayoutSubviews()
* viewDidAppear—>
* viewWillDisappear—>
* viewDidDisappear—>
* viewWillUnload->
* viewDidUnload—>
* dealloc


#### 为什么在主线程更新UI

* UIKit并不是一个 线程安全 的类，UI操作涉及到渲染访问各种View对象的属性，如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度。
* 另一方面因为整个程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以view只能在主线程上才能对事件进行响应。
* 而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。

#### 离屏渲染出发的场景有以下：

1、layer.shouldRasterize（光栅化）

光栅化概念：将图转化为一个个栅格组成的图象。

光栅化特点：每个元素对应帧缓冲区中的一像素。

2、masks（遮罩）

3、shadows（阴影）

4、edge antialiasing（抗锯齿）

5、group opacity（不透明）

6、复杂形状设置圆角等

7、渐变

8、drawRect

## 属性

### ivar、getter、setter 是如何生成并添加到这个类中的?

* OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。
* setter 与 getter 方法对应的实现函数
* ivar_list ：成员变量列表
* method_list ：方法列表
* prop_list ：属性列表

也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.

### checklist

#### @protocol和category中如何使用@property

* 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性
* category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：objc_setAssociatedObject和objc_getAssociatedObject

#### 各个修饰词

- assign
	- : assign一般用来修饰基本的数据类型，包括基础数据类型 （NSInteger，CGFloat）和C数据类型（int, float, double, char, 等等），为什么呢？assign声明的属性是不会增加引用计数的，也就是说声明的属性释放后，就没有了，即使其他对象用到了它，也无法留住它，只会crash。但是，即使被释放，指针却还在，成为了野指针，如果新的对象被分配到了这个内存地址上，又会crash，所以一般只用来声明基本的数据类型，因为它们会被分配到栈上，而栈会由系统自动处理，不会造成野指针。
- retain： 
	- : 与assign相对，我们要解决对象被其他对象引用后释放造成的问题，就要用retain来声明。retain声明后的对象会更改引用计数，那么每次被引用，引用计数都会+1，释放后就会-1，即使这个对象本身释放了，只要还有对象在引用它，就会持有，不会造成什么问题，只有当引用计数为0时，就被dealloc析构函数回收内存了。	
	- strong在修饰block的时候就相当于copy，而retain修饰block的时候就相当于assign，这样block会出现提前被释放掉的危险。
- copy： 
	- NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
	- block也经常使用copy关键字，具体原因见官方文档：Objects Use Properties to Keep Track of Blocks：
		- block使用copy是从MRC遗留下来的“传统”,在MRC中,方法内部的block是在栈区的,使用copy可以把它放到堆区.在ARC中写不写都行：对于block使用copy还是strong效果是一样的，但写上copy也无伤大雅，还能时刻提醒我们：编译器自动对block进行了copy操作。
	- 最常见到copy声明的应该是NSString。copy与retain的区别在于retain的引用是拷贝指针地址，而copy是拷贝对象本身，也就是说retain是浅复制，copy是深复制，如果是浅复制，当修改对象值时，都会被修改，而深复制不会。之所以在NSString这类有可变类型的对象上使用，是因为它们有可能和对应的可变类型如NSMutableString之间进行赋值操作，为了防止内容被改变，使用copy去深复制一份。copy工作由copy方法执行，此属性只对那些实现了NSCopying协议的对象类型有效 。
	- 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？
		- 若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopyiog与NSMutableCopying协议。
		- 具体步骤：
			- 需声明该类遵从NSCopying协议
			 			- 实现NSCopying协议。该协议只有一个方法: `- (id)copyWithZone: (NSZone*) zone` / `mutableCopyWithZone`			 
	- 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？
		- 因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.
		- 如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.
- weak 
	- 什么情况下使用weak
		- 在ARC中，在游客额能出现循环引用的时候，往往需要通过让其中一端使用weak来解决，比如delegate
		- 自身已经对它进行一次强引用，没必要再引用一遍。此时也会使用weak。
	- : weak是弱引用，用weak描述修饰或者所引用对象的计数器不会加一，并且会在引用的对象被释放的时候自动被设置为nil ; 
- __block
	- 变量的指针在定义前在栈区，进入了block区域就变成了堆区。Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。
	- block变量定义时为什么用copy？block是放在哪里的？ block的循环引用并不是strong导致的…在ARC环境下，系统底层也会做一次copy操作使block从栈区复制一块内存空间到堆区…所以strong和copy在对block的修饰上是没有本质区别的，只不过copy操作效率高而已
- assign vs weak
	- assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。
	- assign其实也可以用来修饰对象。那么我们为什么不用它修饰对象呢？因为被assign修饰的对象（一般编译的时候会产生警告：Assigning retained object to unsafe property; object will be released after assignment）在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil，造成野指针。对象一般分配在堆上的某块内存，如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。
 	- 那为什么可以用assign修饰基本数据类型？因为基础数据类型一般分配在栈上，栈的内存会由系统自己自动处理，不会造成野指针。
- `__block` vs `__weak`
	- `__block` 是用来修饰一个变量，这个变量就可以在block中被修改
	- `__block`：使用 __block修饰的变量在block代码块中会被retain（ARC下会retain，MRC下不会retain）
	- `__weak`：使用__weak修饰的变量不会在block代码块中被retain
- strong vs copy 
	- strong 与copy都会使引用计数加1，但strong是两个指针指向同一个内存地址，copy会在内存里拷贝一份对象，两个指针指向不同的内存地址
- @property
	- “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。
	- 我们每次在增加一个属性,系统都会在ivar_list中添加一个成员变量的描述,在method_list中增加setter与getter方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出setter与getter方法对应的实现,在setter方法中从偏移量的位置开始赋值,在getter方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.
	- @protocol 和 category 中如何使用 @property
		-  在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性
		-  category 使用 @property 也是只会生成setter和getter方法的声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数：
			- ①objc_setAssociatedObject
			- ②objc_getAssociatedObject
	- @synthesize和@dynamic分别有什么作用？
		- 1）@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;
		- 2）@synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。
		- 3）@dynamic告诉编译器：属性的setter与getter方法由用户自己实现，不自动生成。（当然对于readonly的属性只需提供getter即可）。假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到instance.var = someVar，由于缺setter方法会导致程序崩溃；或者当运行到 someVar = var时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。
	- @synthesize合成实例变量的规则，有以下几点：
		- 1）如果指定了成员变量的名称,会生成一个指定的名称的成员变量,
		- 2）如果这个成员已经存在了就不再生成了.
		- 3）如果是 @synthesize foo; 还会生成一个名称为foo的成员变量，也就是说：如果没有指定成员变量的名称会自动生成一个属性同名的成员变量。
		- 4）如果是 @synthesize foo = _foo; 就不会生成成员变量了.
	- 什么情况下不会autosynthesis（自动合成）？
		- 同时重写了setter和getter时
		- 重写了只读属性的getter时
		- 使用了@dynamic时
		- 在 @protocol 中定义的所有属性
		- 在 category 中定义的所有属性
		- 重载的属性 / 当你在子类中重载了父类中的属性，你必须 使用@synthesize来手动合成ivar。
- ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？
	- 对应基本数据类型默认关键字是 `atomic,readwrite,assign`
	- 对于普通的OC对象 `atomic,readwrite,strong`

## KVO KVC

### checklist

#### KVC(Key-value coding)

```objc
-(id)valueForKey:(NSString *)key;
-(void)setValue:(id)value forKey:(NSString *)key;
```

#### KVO

KVO (Key-value observing)
KVO是观察者模式的另一实现。
使用了isa混写(isa-swizzling)来实现KVO

使用setter方法改变值KVO会生效，使用setValue:forKey即KVC改变值KVO也会生效，因为KVC会去调用setter方法

```
- (void)setValue:(id)value
{
    [self willChangeValueForKey:@"key"];
    
    [super setValue:value];
    
    [self didChangeValueForKey:@"key"];
}
```


## 持久化 数据库


# 跨平台

## [React Native](http://blog.poetries.top/2019/10/02/rn-yuanli/)

* RCTRootView
	* RCTRootView继承自UIView, RCTRootView主要负责初始化JS Environment和React代码，然后管理整个运行环境的生命周期。
	* 创建并且持有RCTBridge
	* 加载JS Bundle并且初始化JS运行环境.
	* 初始化JS运行环境的时候在App里面显示loadingView,
	* JS运行环境准备好以后把加载视图用RCTRootContentView替换加载视图
	* 有准备工作就绪以后调用AppRegistry.runApplication正式启动RN JS代码，从Root Component()开始UI绘制
* RCTRootContentView
	* RCTRootContentView继承自RCTView, RCTView继承自UIView, RCTView封装了React Component Node更新和渲染的逻辑， RCTRootContentView会管理所有react ui components. RCTRootContentView同时负责处理所有touch事件
*  RCTBridge
	* 这是一个加载和初始化专用类，用于前期JS的初始化和原生代码的加载
	* 负责加载各个Bridge模块供JS调用
	* 找到并注册所有实现了RCTBridgeModule protocol的类, 供JS后期使用.
	* 创建和持有 RCTBatchedBridge
* RCTBatchedBridge
	* 如果RCTBridge是总裁, 那么RCTBatchedBridge就是副总裁。前者负责发号施令，后者负责实施落地
	* 负责Native和JS之间的相互调用(消息通信)
	* 持有JSExecutor
	* 实例化所有在RCTBridge里面注册了的native node_modules
	* 创建JS运行环境, 注入native hooks 和modules, 执行 JS bundle script
	* 管理JS run loop, 批量把所有JS到native的调用翻译成native invocations
	* 批量管理原生代码到JS的调用，把这些调用翻译成JS消息发送给JS executor
* RCTJavaScriptLoader
	* 这是实现远程代码加载的核心。热更新，开发环境代码加载，静态jsbundle加载都离不开这个工具。
	* 从指定的地方(bundle, http server)加载 script bundle
	* 把加载完成的脚本用string的形式返回
	* 处理所有获取代码、打包代码时遇到的错误
* RCTModuleMethod
	* 记录所有原生代码的导出函数地址(JS里面是不能直接持有原生对象的)，同时生成对应的字符串映射到该函数地址。JS调用原生函数的时候会通过message的形式调用过来
	* 记录所有的原生代码的函数地址，并且生成对应的字符串映射到该地址
	* 记录所有的block的地址并且映射到唯一的一个id
	* 翻译所有J2N call，然后执行对应的native方法	
* MessageQueue
	* 这是核心中的核心。整个react native对浏览器内核是未做任何定制的，完全依赖浏览器内核的标准接口在运作。它怎么实现UI的完全定制的呢？它实际上未使用浏览器内核的任何UI绘制功能，注意是未使用UI绘制功能。它利用javascript引擎强大的DOM操作管理能力来管理所有UI节点，每次刷新前把所有节点信息更新完毕以后再给yoga做排版，然后再调用原生组件来绘制。javascript是整个系统的核心语言。
	* 我们可以把浏览器看成一个盒子，javascript引擎是盒子里面的总管，DOM是javascript引擎内置的，javascript和javascript引擎也是无缝链接的。react native是怎么跳出这个盒子去调用外部原生组件来绘制UI的呢？秘密就在MessageQueue。
	* javascript引擎对原生代码的调用都是通过一套固定的接口来实现，这套接口的主要作用就是记录原生接口的地址和对应的javascript的函数名称，然后在javascript调用该函数的时候把调用转发给原生接口
* 原生代码初始化
	* 这里讨论的主要是RN相关的原生代码和用户自定义的RN模块的原生代码的加载和初始化。原生代码初始化主要分两步
	* 静态加载。iOS没有动态加载原生代码的接口，所有的代码都在编译的初期就已经编译为静态代码并且链接好，程序启动的时候所有的原生代码都会加载好。这是原生代码的静态加载，iOS里面没有动态加载原生代码的概念，这也是为何没有静态代码热更新的原因
	* RN模块解析和注入JS。这是加载的第二步。在RootView初始化的时候会遍历所有被标记为RCTModule的原生模块，生成一个json格式的模块信息，里面包含模块名称和方法名称，然后注入到JS Engine, 由MessageQueue记录下来。原生代码在生成json模块信息的时候同时会在原生代码这边维护一个名称字典，用来把模块和方法的名称映射到原生代码的地址上去，用于JS调用原生代码的翻译
	* NativeModules加载
		* 在OC里面，所有NativeModules要加载进JS Engine都必须遵循一定的协议(protocol)。
		* 模块(OC里面的类)需要声明为, 然后在类里面还必须调用宏RCT_EXPORT_MODULE() 用来定义一个接口告诉JS当前模块叫什么名字。这个宏可以接受一个可选的参数，指定模块名，不指定的情况下就取类名。
		* 对应的JS模块在初始化的时候会调用原生类的[xxx new]方法- 模块声明为<RCTBridgeModule>后只是告诉Native Modules这有一个原生模块，是一个空的模块。要导出任何方法给JS使用都必须手动用宏RCT_EXPORT_METHOD来导出方法给JS用.
		* 所有的原生模块都会注册到NativeModules这一个JS模块下面去，你如果想要让自己的模块成为一个顶级模块就必须再写一个JS文件封装一遍NativeModules里面的方法。	
* JS Engine不直接管理UI的绘制
	* 所有的绘制由原生控制的UI事件和Timer触发
	* 影响界面刷新的事件发生以后一部分直接由原生控件消化掉，直接更新原生控件。剩下的部分会通过Bridge派发给MessageQueue，然后在JS层进行业务逻辑的计算，再由React来进行Virtual Dom的管理和更新。Virtual Dom再通过MessageQueue发送重绘指令给对应的原生组件进行UI更新
* 三个线程
	* Shadow queue. 布局引擎(yoga)计算布局用的
		* 可以看到Shadow queue是queue而不是thread, 在iOS里面queue是thread之上的一层抽象,GCD里面的一个概念，创建queue的时候可以指定是并行的还是串行的。也就是说，一个queue可能对应多个thread
	* Main thread. 主线程。就是操作系统的UI线程。无论是iOS还是android，一个进程都只有一个UI线程，我们常说的主线程. React Native所有UI绘制也是由同一个UI线程来维护
	* Javascript thread. javascript线程。 大家都知道javascript是单线程模型，event驱动的异步模型。React Native用了JS引擎，所以也必需有一个独立的js 线程. 所有JS和原生代码的交互都发生在这个线程里。死锁，异常也最容易发生在这个线程

![](http://blog.poetries.top/img-repo/2019/10/681.jpg)

# 业务




## h5 首屏优化 | webview打开优化 | 服务端渲染

- 首屏渲染 【降低请求量 加快请求速度 缓存 渲染】
    - [React 16 加载性能优化指南](https://juejin.im/entry/5b03afd351882542ac7d9291)
    - [首屏优化](https://github.com/fygethub/blog/issues/8)
    * 一. 打开页面 -> 首屏
        * html root节点添加loading
            - 使用 html-webpack-plugin 自动插入 loading
            - 使用 prerender-spa-plugin 渲染首屏
        * 移除外链css
        * 通过webpack的UglifyJsPlugin插件对代码进行压缩
    * 二. 首屏 -> 首次内容渲染
        * 缓存 基础框架，如 React、Vue 等，这些基础框架的代码是不变的，除非升级框架；
            * 服务器缓存
            * js加载速度主要是通过webpack提取不易改变的js库,例如react, react-dom, react-router...等, 打包成dell文件通过配置cdn 使js能下载的更快.
        * 动态 polyfill 
        * 使用 SplitChunksPlugin 自动拆分业务基础库
    * 三、首次内容渲染 -> 可交互
        * Code Splitting 可以帮你“懒加载”代码，以提高用户的加载体验，如果你没办法直接减少应用的体积，那么不妨尝试把应用从单个 bundle 拆分成单个 bundle + 多份动态代码的形式。
            * `import("./math").then` /  React Loadable  动态路由只加载当前路由匹配的组件。
        * 编译到 ES2015+ ，提升代码运行效率
    * 四、可交互 -> 内容加载完毕 (主要是各种多媒体内容的加载)
        * LazyLoad + placeholder
- 原生端优化
	- [移动 H5 首屏秒开优化方案探讨](https://blog.cnbang.net/tech/3477/)
	* html/js/css缓存 [手Q两种缓存](https://mp.weixin.qq.com/s/evzDnTsHrAr2b9jcevwBzA?)
		* 预加载列表 | 客户端接管缓存，实现缓存机制 | httpdns+https 缓存文件防止被劫持
		* 离线包+公共资源包 （解决文件分散管理管理问题 | 前加载进内存，减少磁盘 IO 耗时 | 增量更新方便加密签名
	* webview预加载 [美团webview优化调研](https://tech.meituan.com/2017/06/09/webviewperf.html)
		* 首次预加载：在一个进程内首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因预计是 webview 首次初始化后，即使 webview 已经释放，但一些多 webview 共用的全局服务或资源对象仍没有释放，第二次初始化时不需要再生成这些对象从而变快。我们可以在 APP 启动时预先初始化一个 webview 然后释放，这样等用户真正走到 H5 模块去加载 webview时就变快了。
		* webview 池：可以用两个或多个 webview 重复使用，而不是每次打开 H5 都新建 webview。不过这种方式要解决页面跳转时清空上一个页面，另外若一个 H5 页面上 JS 出现内存泄漏，就影响到其他页面，在 APP 运行期间都无法释放了。
	* 使用客户端接口
		* 网路和存储接口如果使用 webkit 的 ajax 和 localStorage 会有不少限制，难以优化，可以在客户端提供这些接口给 JS，客户端可以在网络请求上做像 DNS 预解析/IP直连/长连接/并行请求等更细致的优化，存储也使用客户端接口也能做读写并发/用户隔离等针对性优化。


## linkmap

[给“爸爸”添麻烦 - iTOP iOS 动态库改造](https://cloud.tencent.com/developer/article/1071843)
[iOS优化-包大小分析-linkMap](https://dishibolei.github.io/2017/08/17/ios-linkmap/)

- linkmap文件结构
	- Object files：目标文件列表 
	- Sections：段表，描述各个段在最后编译成的可执行文件中的偏移位置和大小，包括了代码段（__TEXT，保存程序代码段编译后的机器码）和数据段（__DATA，保存变量值）
	- Symbols：详细描述按每个文件列出每个对应字段的位置和占用空间
	- Dead Stripped Symbols
- 代码段大小统计
	- 遍历 Link Map 文件第三部分 Symbols 里的每一行，将文件编号（第三列）为[4] 的数据都取出，将每一行的 size（第二列）相加，就是这个目标文件的大小	
	- 各版本间静态库大小对比


## 崩溃

* Bad Memory Access [EXC_BAD_ACCESS ( SIGSEGV | SIGBUS)]
    * SGSEGV 试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据
    * SIGBUS 非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于，后者是由于对合法存储地址的非法访问触发的


## iOS app启动优化

* [iOS应用启动性能优化资料](https://everettjf.github.io/2018/08/06/ios-launch-performance-collection/)
* [今日头条iOS客户端启动速度优化](https://techblog.toutiao.com/2017/01/17/iosspeed/)


> 怎么线上监控？

* App总启动时间 = t1:main()之前加载时间 + t2:main()之后的加载时间
	* t1: 系统dylib(动态链接库)和自身App可执行文件的加载
	* t2: main()函数之后到 appdelegate类中的 `didFinishLaunchWithOptions:` 方法结束前这段时间，主要构建第一个界面，并完成渲染展示。
* main()调用之前的加载过程
	* App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合）
	* 然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。
	* 执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。 在这一步，runtime被初始化。当所有依赖库的初始化后，轮到最后一位(程序可执行文件)进行初始化，在这时runtime会对项目中所有类进行类结构初始化，然后调用所有的load方法。最后dyld返回main函数地址，main函数被调用，我们便来到了熟悉的程序入口。
* 最多的用时还是在image加载和OC类的初始化，共占用总时长的79.3%，精简framework的引入和OC类有优化的空间。优化点：
	* 减少不必要的framework，因为动态链接比较耗时 | 不要自己使用dlopen方法，让系统来处理模块加载
	* 合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下：
	* 删减一些无用的静态变量 | 删减没有被调用到或者已经废弃的方法
	* 将不必须在+load方法中做的事情延迟
* 对于main()函数调用之前我们可以优化的点有：
	* 不使用xib，直接视用代码加载首页视图 | 首页骨架屏 默认数据
	* NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)
	* 每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log
	* 对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。 对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载

## iOS 包大小

* [干货！京东商城iOS App瘦身实践](https://mp.weixin.qq.com/s/xzlFQJ2b-rrw5QIszSLXXQ)
* [干货|今日头条iOS端安装包大小优化](https://www.jianshu.com/p/a3151dfebc9c)


（1）删除Swift代码，从混编改为纯OC编程
（1）无用资源文件清理 图片资源 asset.car
（2）无用类清理，无用第三方库清理
（3）部分资源文件云端下载 rn
（4）使用iconfont /tint color精简图标

## Universal Links debug

* 配置 apple-app-site-association
* 安装 卸载 apple-app-site-association文件，所以测试时有可能因为网络波动导致apple-app-site-association文件获取失败。这种情况，多卸载几次，安装时使用4G
* [Sysdiagnose 文件](https://bianwangui.xyz/2019/02/18/2019/iOS%20%E6%97%A5%E5%BF%97%E6%8F%90%E5%8F%96/)
* swcutil_show.txt 


## iOS 无埋点

无埋点的具体实现，用到的主要是AOP(Aspect-Oriented-Programming)，面向切面编程，面对的是处理过程中的某个步骤和方法。在运行时，动态的将代码插入到类的制定方法、指定位置上的编程思想就是面向切面编程。

* C 的 AOP 使用了 dyld(dynamic link editor) fishhook
* oc 利用method_exchangeImplementations、class_replaceMethod、method_setImplementation等方法偷换selector的IMP

* 事件唯一ID的确定
	* 主要由view的层级结构path路径、该view的所在页面类名以及view所带的一些自身固定属性等构成
	* 不同类型的UIView不需要做index的区分，那么在获取这个index的时候，不是简单的从subviews这个数组中获取其对应的索引值，而是进行一个简单的同类归并再取索引值，一个很简单的处理。
	* 该UIAlertController的message和title信息
* UI无埋点
	* UIControl sendAction:to:forEvent: | endTrackingWithTouch:withEvent:方法可以监控UIControl的触摸事件。
	* UITableView UITableViewDelegate的tableView:didSelectRowAtIndexPath:方法可以监控到UITableView的点击事件。
	* UICollectionView collectionView:didSelectItemAtIndexPath:方法可以监控到UICollectionView的点击事件。
	* UIView UITapGestureRecognizer的initWithTarget:action:方法可以监控到UIView的点击事件。
		* addGestureRecognizer
	* 对于 RN 页面中的点击，是通过 hook RN 框架中的 RCTUIManager 类的 setJSResponder:blockNativeResponder: 方法，具体原因可以看 这篇文章 的详细讲解。另外，为了避免 SDK 对 RN 框架产生依赖，通过 NSClassFromString(@"RCTUIManager") 来判断当前主工程是否使用了 RN 框架，如果未获取到此类，则不执行 hook 操作。

## iOS LSB图片隐写

* 图片格式
* png lsb
* jpeg lsb [基于DCT域的JPG图片隐写+基于DCT域的JPG图片隐写+数字水印隐写](http://chenjingjiu.cn/index.php/2019/04/18/steganography/#seg4)


1. RGB到YCbCr转换（可选），
2. 色度通道的子采样（可选），
3. 8x8块拆分，
4. 像素值重新定位，
5. DCT，
6. 基于压缩比/质量的量化，
7. 以Z字形图案对系数进行排序，
8. 熵编码;最常涉及霍夫曼编码和行程编码（RLE）。

离散余弦变换（Discrete Cosine Transform，DCT）函数来压缩图像，而这个图像压缩方法的核心是：通过识别每个8×8像素块中相邻像素中的重复像素来减少显示图像所需的位数，并使用近似估算法降低其冗余度。

DCT也是将信号从时域到频域的变换

0x21 JSteg隐写算法
JSteg是最早用于JPEG隐写的隐写算法，其核心思想就是将空域的LSB隐写应用到JPEG图像的DCT变换过程中。具体来说，就是将二进制的隐藏信息嵌入到DCT系数的LSB上，如果隐藏信息的二进制数与DCT的LSB相对应的二进制数相同则不替换，否则替换成隐藏信息的二进制数。如图所示。

Jphide隐写过程大致为：先解压压缩JPEG图像，得到DCT系数；然后对隐藏信息用户给定的密码进行Blowfish加密；再利用Blowfish算法生成伪随机序列，并据此找到需要改变的DCT系数，将其末位变为需要隐藏的信息的值。最后把DCT系数重新压回成JPEG图片，下面是个人对隐写过程理解画出的大致流程图。

## iOS Google Palette

怎么解决颜色视觉焦点问题？
RGB色彩模式描述了三种颜色通道，这三种通道组合在一起，便成了我们最终能看到的颜色。它能表示的颜色数目多到惊人，能涵盖人眼能感知的所有色彩范围。但是它无法表示颜色对人眼的吸引程度。那让我们回想以上两张图，我们是不是一下子就被亮丽的蓝色和黄色给吸引了？注意，我用了亮丽这个词。

那什么是亮丽？答案是色彩的饱和度，也就是鲜艳度。以及恰到好处的色彩明度，也就是色彩的亮度。以及足够多的色彩数目，也就是该颜色或者颜色族所代表的像素个数。

(1)压缩图片，遍历图片像素，引出颜色直方图的概念。并将不同的颜色存入新的颜色数组。
(2)判断颜色种类是否大于设定的最大颜色数。
(3)通过VBox分裂的方式，找到代表平均颜色的Swatch。
(4)找到某一种模式下得分最高的Swatch，也就是获得了最终的色调提取值


## iOS 签名

[http://blog.cnbang.net/tech/3386/](http://blog.cnbang.net/tech/3386/)

最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。

一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP;
实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。

苹果这里给出的方案是使用了双层签名，会比较绕，

## 代码优化 以及标准

* 崩溃率 | OOM
* 内存占用 | 循环引用 
* FPS | UI优化
* 启动时间 | 代码时间
* app包优化 | 缓存
* 业务流程优化 减少用户等待时间

# 网络

## OSI多层 [OSI多层](https://blog.csdn.net/huangjin0507/article/details/51613561)

* 第一层：物理层 在这一层，数据的单位称为比特（bit）。
* 第二层：数据链路层
	* 在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。
* 第三层：网络层
	* 在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。如 果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。网络层协议的代表包括：IP、IPX、RIP、OSPF等。
* 第四层：传输层
	* 第4层的数据单元也称作数据包（packets）。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段 （segments）而UDP协议的数据单元称为“数据报（datagrams）”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等。
* 第五层：会话层
	* 这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。
* 第六层：表示层
	* 这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。
	第七层：应用层
	* 应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。

## [一次完整的HTTP请求过程](https://www.jianshu.com/p/eb8eb4ea7286)

域名解析 —> 与服务器建立连接 —> 发起HTTP请求 —> 服务器响应HTTP请求，浏览器得到html代码 —> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片） —> 浏览器对页面进行渲染呈现给用户

## http https

HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

## [http响应码](https://www.runoob.com/http/http-status-codes.html)

* 200成功
* 301 资源重定向 302临时重定向 
* 400 客户端请求的语法错误，服务器无法理解 401 认证
* 500 服务器内部错误

# 设计模式 | 项目架构

* 如何设计底层的工具类，需要注意什么
* 说一下MVC，并画出MVC各层的关系

## 六大原则

* 开闭原则  ：对扩展开放，对修改关闭。
* 里氏代换原则（  任何基类可以出现的地方，子类一定可以出现。
* 依赖倒转原则（ 针对接口编程，依赖于抽象而不依赖于具体。
* 接口隔离原则（使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度
* 迪米特法则， 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
* 合成复用原则 尽量使用合成/聚合的方式，而不是使用继承。

## mvc [mvvm](https://objccn.io/issue-13-1/) 

Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互

以 MVVM 属术语来说，就是那些将 Model 数据转换为 View 可以呈现的东西的事情，例如将一个 NSDate 转换为一个格式化过的 NSString。

## iOS开发实战项目中的应用 [参考](https://www.jianshu.com/p/01753ab19b7b)

* delegate pattern（代理模式）和block的抉择
	* 一个类代表另一个类的功能。
* adapter pattern(适配器模式)的
	* 作为两个不兼容的接口之间的桥梁。
* singleton pattern（单例模式）
* 观察者模式 NSNotificationCenter KVO
	* 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。


## 如何设计底层的工具类

* 封装/解耦 ; 封装第三方库
* 抽象 ： 参数能不能使用父类
* 便捷性与灵活性并存 ：复用：关键点，多想一步，根据参数变化编写各种类型的入参函数，需要保证函数主要代码只有一份。
* 方法优先于对象
* 适配与兼容
* 过度设计
* 迪米特法则 减少依赖 | 非侵入式框架 AOP
* 如果工具类中有异常，请抛出，不要自己去 try-catch。更不要 try 了之后 e.printStackTrace() 。
* 还有就是工具类中要不要打印日志问题，尽量不要打印，像 log4j 这样的一些第三方日志框架也不要用。降低于第三方类库的依赖。


## 项目结构

>关于MVC架构的在工程中两种体现形式
1.有很多项目是直接在工程里创建Controllers、Views、Models这样的目录结构...这样归类
2.按 Feature来划分，每个Feature里面有Controllers、Views、Models...这样归类

ios开发分工有两种，一种是分层开发，第一种形式适合分层开发，一种是分feature开发，第二种形式适合分feature开发。分层开发通常是有人负责DAO层（数据存取）开发，有人负责控制器和view层的开发，但是当API尚未形成，而且Dao层同事对业务层关注不够，DAO层开发的的同事就完全需要依靠自身的想象力去设计数据存取的接口，而往往这和实际API提供的接口存在巨大的落差，从而导致分层开发的各层都会做出大量代码重构。所以分feature开发是大家比较容易接受的一种开发方式。

所以我的建议：是采用第二种MVC组织形式，如果你采用MVVM或者其他，也可以参考此思路。其实第一种形式还有一个问题，比如你要找ControllerA的TableView用到的cellB类，你还要去Views里面一个个找，太痛苦了，就算search也还是苦毕竟不能所见即所得。而分feature则对于负责此feature的开发工程师找到有关文件则容易的多了。

>关于Helper与Utility文件夹
我看过很多项目，包括自己参与过的一些项目要么没有Helper,要么没有Utility文件夹，而是将他们糅在一起，傻傻分不清楚。
我的建议：尽量细粒度化项目目录结构，在项目里分开提供helper目录和utility目录给开发者使用。与业务无关，具有对象性质，提供支持功能的代码放到Helper，比如创建一个自定义对象的封装。如果只是属于函数或算法，不是对象而且很多地方能用到，就放到Utility，比如排序/加密算法。

中间人模式 URL 路由、target-action、protocol

[有赞移动 iOS 组件化（模块化）架构设计实践](https://tech.youzan.com/you-zan-ioszu-jian-hua-jia-gou-she-ji-shi-jian/)
[打造完备的iOS组件化方案：如何面向接口进行模块解耦](https://zuikyo.github.io/2019/07/15/iOS_inrerface_orientation_modularization/)

