# iOS-多线程

多线程是是为了充分的利用系统的多核解决并发操作的技术方,进而提升整体处理性能。

- 多线程的实现原理：同一时间内单核的CPU只能执行一个线程，多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。

- 如果是多核CPU就真的可以同时处理多个线程了。

  

**好处：**

能适当提高程序的执行效率
能适当提高资源利用率（CPU、内存利用率）

**缺点：**

开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能
线程越多，CPU在调度线程上的开销就越大
程序设计更加复杂：比如线程之间的通信、多线程的数据共享,需要防止线程死锁情况的发生。



实现多线程的方法：

### NSThread

NSThread 官方提供面向对象操作线程的技术，可以直接操作线程对象，需要自己控制线程的生命周期。



### NSOpetration

NSOperation 是一个抽象类，它封装了线程的细节实现，不需要自己管理线程的生命周期和线程的同步和互斥等。只是需要关注自己的业务逻辑处理，需要和 NSOperationQueue 一起使用。使用 NSOperation 时，你可以很方便的设置线程之间的依赖关系。这在略微复杂的业务需求中尤为重要。

### GCD

GCD 充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。



首先要了解下面几个概念：

- Dispatch Queue：Dispatch Queue 顾名思义，是一个用于维护任务的队列，它可以接受任务（即可以将一个任务加入某个队列）然后在适当的时候执行队列中的任务。
- Dispatch Sources：Dispatch Source 允许我们把任务注册到系统事件上，例如 socket 和文件描述符，类似于 Linux 中 epoll 的作用
- Dispatch Groups：Dispatch Groups 可以让我们把一系列任务加到一个组里，组中的每一个任务都要等待整个组的所有任务都结束之后才结束，类似 pthread_join 的功能
- Dispatch Semaphores：这个更加顾名思义，就是大家都知道的信号量了，可以让我们实现更加复杂的并发控制，防止资源竞争

这些东西中最经常用到的是 Dispatch Queue。之前提到 Dispatch Queue 就是一个类似队列的数据结构，而且是 FIFO(First In, First Out)队列，因此任务开始执行的顺序，就是你把它们放到 queue 中的顺序。GCD 中的队列有下面三种：

1. Serial （串行队列） 串行队列中任务会按照添加到 queue 中的顺序一个一个执行。串行队列在前一个任务执行之前，后一个任务是被阻塞的，可以利用这个特性来进行同步操作。

   我们可以创建多个串行队列，这些队列中的任务是串行执行的，但是这些队列本身可以并发执行。例如有四个串行队列，有可能同时有四个任务在并行执行，分别来自这四个队列。

2. Concurrent（并行队列） 并行队列，也叫 global dispatch queue，可以并发地执行多个任务，但是任务开始的顺序仍然是按照被添加到队列中的顺序。具体任务执行的线程和任务执行的并发数，都是由 GCD 进行管理的。

   在 iOS 5 之后，我们可以创建自己的并发队列。系统已经提供了四个全局可用的并发队列，后面会讲到。

3. Main Dispatch Queue（主队列） 主队列是一个全局可见的**串行**队列，其中的任务会在主线程中执行。主队列通过与应用程序的 runloop 交互，把任务安插到 runloop 当中执行。因为主队列比较特殊，其中的任务确定会在主线程中执行，通常主队列会被用作同步的作用。

   

- GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用胡话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护（看到这句话是不是很开心？） 而我们程序员需要关心的是什么呢？我们只关心的是向队列中添加任务，队列调度即可。
- 如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。
- 如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。
- 这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。

```dart
// 核心概念：
// 任务：block
// 队列：把任务放到队列里面，队列先进先出的原则，
// 串行队列：顺序，一个一个执行(必须一个任务执行完了，才能从队列里面取出下一个任务)
// 并发队列：同时，同时执行很多个任务（可以同时取出很多个任务，只要有线程去执行）

// 同步sync：不会开新线程
// 异步async：会开新线程，多线程的代名词

// 串行队列同步执行：不开线程，在原来线程里面一个一个顺序执行
// 串行队列异步执行：开一条线程，在这个新线程里面一个一个顺序执行
// 并发队列异步执行：开多个线程，并发执行（不一定是一个一个）执行
// 并发队列同步执行：不开线程，在原来线程里面一个一个顺序执行

// 阶段性总结：
// 1. 开不开线程，由执行任务方法决定，同步不开线程，异步肯定开线程
// 2. 开多少线程，由队列决定，串行最多开一个线程， 并发可以开多个线程。 具体开多少线程由GCD底层决定

/**
 队列的选择：
 串行队列异步执行
 -  开一条线程, 顺序执行
 -  效率：不高，执行比较慢，资源占用小 -》 省电
 一般网络是3G，对性能要求不会很高。
 
 并发队列异步执行
 - 开启多条线程，并发执行
 - 效率：高，执行快，资源消耗大-》费电
 使用场合：
 - 网络WiFi，或者需要很快的响应，要求用户体验非常流畅。
 -对任务执行顺序没有要求
 -同步任务：一般只会在并发队列， 需要阻塞后续任务。必须等待同步任务执行完毕，再去执行其他任务。"依赖"关系
 */
```



## GCD 与 NSOperation 的对比

这这两个都很常用，也都很强大。对比它们可以从下面几个角度来说：

- 首先要明确一点，NSOperationQueue 是基于 GCD 的更高层的封装，从 OS X 10.10 开始可以通过设置 `underlyingQueue` 来把 operation 放到已有的 dispatch queue 中。

- 从易用性角度，GCD 由于采用 C 风格的 API，在调用上比使用面向对象风格的 NSOperation 要简单一些。

- 从对任务的控制性来说，NSOperation 显著得好于 GCD，和 GCD 相比支持了 Cancel 操作（注：在 iOS8 中 GCD 引入了 `dispatch_block_cancel` 和 `dispatch_block_testcancel`，也可以支持 Cancel 操作了），支持任务之间的依赖关系，支持同一个队列中任务的优先级设置，同时还可以通过 KVO 来监控任务的执行情况。这些通过 GCD 也可以实现，不过需要很多代码，使用 NSOperation 显得方便了很多。

- 从第三方库的角度，知名的第三方库如 AFNetworking 和 SDWebImage 背后都是使用 NSOperation，也从另一方面说明对于需要复杂并发控制的需求，NSOperation 是更好的选择（当然也不是绝对的，例如知名的 [Parse SDK](https://github.com/ParsePlatform/Parse-SDK-iOS-OSX) 就完全没有使用 NSOperation，全部使用 GCD，其中涉及到大量的 GCD 高级用法，[这里](https://github.com/ChenYilong/ParseSourceCodeStudy)有相关解析）。




[iOS多线程总结](https://juejin.cn/post/6844903806291935240)

[iOS多线程总结](https://mp.weixin.qq.com/s?__biz=MzU3MjY2OTEwNg==&mid=2247486153&idx=1&sn=85d6196f656ed128b9dfde97ade5b19a&chksm=fccc2714cbbbae02e2db8f48c0188505159ad3be97dd35fcc8c976690e99dd32a4cc834bad53&scene=132#wechat_redirect)

[iOS多线程](https://www.cnblogs.com/weiming4219/p/7649661.html)

[iOS底层探索之多线程](https://juejin.cn/post/7000599608376164389)

[『NSOperation、NSOperationQueue』详尽总结](https://www.jianshu.com/p/4b1d77054b35)



