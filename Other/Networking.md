#### 1、API接口如何防止参数被篡改和重放攻击？

API参数篡改：就是恶意人通过抓包的方式获取到请求的接口的参数，通过修改相关的参数，达到欺骗服务器的目的，常用的防止篡改的方式是用签名以及加密的方式。

API重放攻击: 就是把之前窃听到的数据原封不动的重新发送给接收方.

#### 基于timestamp和nonce的方案

##### timestamp的作用

每次HTTP请求，都需要加上timestamp参数，然后把timestamp和其他参数一起进行数字签名。HTTP请求从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间相比较，是否超过了60s，如果超过了则认为是非法的请求。

一般情况下,从抓包重放请求耗时远远超过了60s，所以此时请求中的timestamp参数已经失效了,如果修改timestamp参数为当前的时间戳，则signature参数对应的数字签名就会失效，因为不知道签名秘钥，没有办法生成新的数字签名。

但这种方式的漏洞也是显而易见的，如果在60s之后进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效

##### nonce的作用

nonce的意思是仅一次有效的随机字符串，要求每次请求时，该参数要保证不同。我们将每次请求的nonce参数存储到一个“集合”中，每次处理HTTP请求时，首先判断该请求的nonce参数是否在该“集合”中，如果存在则认为是非法请求。

nonce参数在首次请求时，已经被存储到了服务器上的“集合”中，再次发送请求会被识别并拒绝。

nonce参数作为数字签名的一部分，是无法篡改的，因为不知道签名秘钥，没有办法生成新的数字签名。

这种方式也有很大的问题，那就是存储nonce参数的“集合”会越来越大。

nonce的一次性可以解决timestamp参数60s(防止重放攻击)的问题，timestamp可以解决nonce参数“集合”越来越大的问题。

#### 2、TCP和UDP的区别

- `TCP`：传输控制协议。面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。
- `UDP`：用户数据协议。是面向无连接的，数据传输快但不可靠，它只管发，不管收不收得到。

1.基于连接与无连接；
2.对系统资源的要求（TCP较多，UDP少）；
3.UDP程序结构较简单；
4.流模式与数据报模式 ；
5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证

```
TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。
UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。
```



### TCP是如何保证可靠性

1、校验和，检验范围包括TCP首部及数据部分。将报文分段，所有段反码相加，最终结果为全1

2、确认应答与序列号，按序，不缺，去重，多次发送，一次确认

3、超时重传

4、连接管理，三次握手四次挥手

5、流量限制，16位的窗口。

6、拥塞控制，慢启动、拥塞避免、拥塞发生、快重传、快恢复



### TCP三次握手和四次挥手？

三次握手

- 1、客户端向服务端发起请求链接，发送报文，`seq=x`，客户端进入SYN_SENT状态
- 2、服务端收到请求链接，回复确认报文，`seq=y`，`ACK=x+1`，并且服务端进入到SYN_RCVD状态
- 3、客户端收到确认报文后，回复报文，`ACK=y+1`，此时客户端进入到ESTABLISHED，服务端收到用户端发送过来的确认报文后，也进入到ESTABLISHED状态，此时链接创建成功

四次挥手

- 1、客户端向服务端发起关闭链接请求，并停止发送数据
- 2、服务端收到关闭请求时回复，收到，然后停止接收数据
- 3、当服务端发送数据结束之后，向客户端发起关闭链接请求，并停止发送数据
- 4、客户端收到关闭请求时回复，收到，然后停止接收数据

### 为什么需要三次握手？

- 防止已失效的连接请求报文段突然又传送到了服务端，产生错误。
- 假设不采用三次握手，只要服务器收到链接请求并发出确认，新的连接就建立了。
- 假设现在有一个已失效的连接请求报文段延迟收到了，服务端误认为是客户端要建立新连接，于是回复了确认报文并认为成功建立了连接。实际上客户端并没有建立连接的打算，不会处理服务端的确认报文也不会发送数据。服务端此时一直等待数据，这样就浪费掉很多资源。

### 为什么需要四次挥手？

- `TCP`是全双工通信的，服务端接收到客户端的关闭请求时，可能还在向客户端发送着数据。
- 只能先回复一个收到，发送完原来的数据后再发送关闭请求。


