## IM消息空洞

IM消息分为**即时消息、离线消息、历史消息**

业务下行空洞原理、下行消息乱序的原因
1、服务端分布式存储，同一个Session的消息在同一个集群，但是可能分布在不同的机器。异常情况会有乱序、空洞的情况发生，所以需要SDK做兜底处理。
2、客户端掉线后最后一条收到的消息为x，当客户端重连时收到的消息可能时x+n(掉线过程中有很多消息没有成功接收)，此时就造成了消息空洞。

**1. 纯推模式**

**优势**：实时

**缺点**：当在线好友量很大时，任何一个用户状态的改变，会扩散成N个实时通知，这个N叫做“消息风暴扩散系数”。

###### 场景1: 新设备登陆初始化

服务端推送**全量**的消息记录到客户端，历史消息量大的时候，非常浪费服务端资源和带宽。

###### 场景2: 设备间切换

1. 用户1在设备A上登陆，收到了用户2的消息1和2，push到了设备A上。
2. 用户1退出了设备A，用户2又给他发送了消息3和4
3. 用户1登陆了设备B，服务端push消息3和4到了设备B

但是此时，设备B缺少了消息1和2，用户再登陆回设备A的话又缺少了消息3和4，这也就产生了「**消息空洞**」

   

**2. 纯拉模式**
客户端需要和服务端进行一个长轮询，来定时检查是否存在新消息，并进行消息拉取。



**总结**

状态的实时性与一致性是一个较难解决的技术问题，不同的业务实现方式不同，一般来说：

- **好友状态同步**，是采用推送的方式同步
- **群友状态同步**，由于消息风暴扩散系数过大，一般采用拉取的方式同步
- **群友状态同步**，还能采用按需拉取的优化方式，进一步降低服务端压力



推拉模式分别适用于业务中的不同场景需要，所以我们要使用推拉结合的方式来做。
拉模式适合的场景如下：

1. 设备初始化时：先拉取会话列表，在根据会话的列表来为每个会话拉取一定的消息记录。可以通过控制拉取的数据量，减轻服务端压力。
2. 历史聊天记录：按需拉取一定条数的记录，用户向上翻取记录再拉取固定条数的记录，直到翻到没有记录（就是翻页）。
