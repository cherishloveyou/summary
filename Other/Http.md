# Http状态码


| 类别  | 重定向，表示浏览器要执行特殊处理                         |
| :--- | :-------------------------------------------------------|
| 1XX  | Infomational（信息状态码）接受的请求正在处理                 |
| 2XX  | Success（成功状态码）请求正常处理完毕                        |
| 3XX  | Redurection（重定向状态码）需要进行附加操作以完成请求          |
| 4XX  | ClientError（客户端错误状态码）服务器无法处理请求             |
| 5XX  | ServerError（服务器错误状态码）服务器处理请求出错             |

| 2XX  | 成功（这系列请求倍正常处理了）                        |
| :--- | :-------------------------------------------------------|
| 200  | OK，表示从客户端发来的请求在服务器端被正确处理                  |
| 204  | No content，表示请求成功，但是响应报文不含实体的主体部分        |
| 206  | Partial content，进行范围请求成功                          |

| 3XX  | 重定向（表示浏览器要执行特殊处理）                                          |
| :--- | :---------------------------------------------------------------------|
| 301  | Moved Permanently，永久性重定向，表示资源被分配了新URL                      |
| 302  | Found，临时性重定向，表示资源被分配了新URL                                  |
| 303  | See Ohter，表示资源存在另一个URL，应使用GET方法获取资源                      |
| 304  | Not Modified，表示服务器允许访问资源，但是请求未满足条件                      |
| 307  | Temporary Redierect，临时重定向，但是期望客户端保持请求方法不变向新地址发出请求  |

| 4XX  | 客户端错误                            |
| :--- | :---------------------------------------------------------------|
| 400  | Bad Request，请求报文存在语法错误                                   |
| 401  | Unauthorize，表示发送请求需要有通过HTTP认证的认证信息                  |
| 403  | Forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述  |
| 404  | Not Found，表示服务器上没找到请求的资源                              |
| 405  | 禁用请求中指定的方法。                                              |

| 5XX  | 服务器错误                            |
| :--- | :-----------------------------------------------------------------|
| 500  | Internal sever error，表示服务器端在执行请求时发送了错误                |
| 501  | Not Implemented，表示服务器不支持当前请求所需要的某个功能                |
| 503  | Service unavailable，表示服务器暂时处于超负荷或者停机维护状态，无法处理请求 |


#### Http请求过程：

​    浏览器请求url-->解析域名-->**先是经过TCP三次握手，建立连接后，才开始TLS握手**-->HTTP连接-->服务器处理文件-->返回数据-->浏览器解析、渲染文件

#### 为什么要加入TLS层？

`HTTP`协议是明文传输，并且不进行对方身份校验，容易被劫持，篡改，中间人拦截，信息泄漏等等。

因此一定要加入防护手段。

##### 为什么不直接使用对称加密方式？

对称加密算法。比如`AES`算法:安全性高，性能也好。

但是最大的问题是：如何把密钥给到对方？

首先不能内置到Client端，因为密钥容易被获取。并且后续无法进行实时更换。

所以一定要想办法传输给对方。

但是又如何保证`安全传输`密钥信息呢？

##### 为什么不全部使用非对称加密？

非对称加密，非常的安全。公钥可以解密私钥加密的数据，私钥可以解密公钥加密的数据。

公钥是公开的，所以传递公钥的问题得以解决了。

但是非对称加密的算法，性能消化比对称加密大，不适合数据传递实时加解密。

**因此可以使用混合加密的方式。 公钥的传递使用非对称加密，后续数据的加解密使用对称加密算法。**

##### 为什么还要涉及到摘要算法？

摘要算法可以对传输内容进行摘要，这个过程不可逆。可以用来防止内容被篡改，保证内容的完整性。

##### 但是这样的方式只解决了数据通信的问题。如何保证和你协商密钥的人是不是你认为的那个人呢？

如果一个人冒充`Server`和你交流，那么你的数据岂不是全部到人家手中了？ 所以，`Client`无法相信任何人的。 那这怎么办呢？



#### Http优化

我们在做性能优化的时候，很多时候会提到的⼀点就是“HTTP 1.1 的队头阻塞问题”，具体来说就是 HTTP2 解决了 HTTP1.1中的队头阻塞问题， 但是为什么 HTTP1.1有队头阻塞问题，HTTP2究竟怎么解决的这个问题，很多人都不清楚。 其实 队头阻塞 是⼀个专有名词，不仅仅在 HTTP 有，交换器等其他地⽅也都涉及到了这个问题。实际上引起这个问题的根本原因是使⽤了队列 这种数据结构。

协议规定， 对于同⼀个tcp连接，所有的http1.0请求放⼊队列中，只有前⼀个请求的响应收到了，才能发送下⼀个请求，这个时候就发⽣了阻塞，并且这个阻塞主要发⽣在客户端。

HTTP/1.0 和 HTTP/1.1 : 

在 HTTP/1.0 中每⼀次请求都需要建⽴⼀个 TCP 连接，请求结束后⽴即 断开连接。 在 HTTP/1.1 中，每⼀个连接都默认是⻓连接 (persistent connection)。 对于同⼀个 tcp 连接，允许⼀次发送多个 http1.1 请求，也就是说，不必等前⼀个响应收到，就可以发送下⼀个请求。这样就解决了 http1.0 的客户端的队头阻塞，⽽这也就是HTTP/1.1 中管道 (Pipeline) 的概念了。

但是， http1.1 规定，服务器端的响应的发送要根据请求被接收的顺序排队 ，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间⻓的话，响应⽣成也慢，就会阻塞已经⽣成了的响应的发送，这也会造成队头阻塞。可⻅，http1.1 的队⾸阻塞是发⽣在服务器端。 

多路复⽤ ⽤以替代原来的序列和拥塞机制。在 HTTP/1.1 中，并发多个请求需要多个 TCP 链接，且单个域名有 6-8 个 TCP 链接请求限制（这个限制是浏览器限制的，不同的浏览器也不⼀定⼀样）。在 HTTP/2 中，同⼀域名下的所有通信在单个链接完成，仅占⽤⼀个 TCP 链接，且在这⼀个链接上可以并⾏请求和响应，互不⼲扰。

#####  为什么HTTP/1.1不能实现“多路复用”？

简单回答就是：**HTTP/2是基于二进制“帧”的协议，HTTP/1.1是基于“文本分割”解析的协议。**

**HTTP2.0和HTTP1.X相比的新特性**

**新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮

**多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面

**header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小

**服务端推送**（server push）例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了

**HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？**

- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，因为传输格式是文本的，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞
- HTTP/2多个请求可同时在一个连接上并行执行（由于支持二进制的格式，可以无序）某个请求任务耗时严重，不会影响到其它连接的正常执行




### 为什么TCP连接的时候是3次？2次不可以吗？

因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。

### 为什么TCP连接的时候是3次，关闭的时候却是4次？

因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。

### 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



### GET和POST的定义

GET方法用于从Web服务器请求数据。在使用GET方法时，浏览器向Web服务器发送一个请求，Web服务器将响应数据发送回浏览器。POST方法用于向Web服务器提交数据。

#### GET和POST的区别

**1.数据传输方式不同**

GET方法的数据传输是通过URL传递的，而POST方法的数据传输是通过HTTP请求体传递的。在使用GET方法时，浏览器将请求的参数附加到URL的末尾，以“?”号开始，并用“&”符号将多个参数连接在一起。

**2.数据大小限制不同**

GET方法将数据附加到URL中，因此数据大小有限制。在URL中，只能传递ASCII字符，并且URL的长度有限制。不同的浏览器和Web服务器对URL长度的限制不同，但通常在2KB到8KB之间。因此，使用GET方法传输大量数据可能会导致URL过长，从而影响请求的性能。

POST方法将数据放在HTTP请求体中，因此数据大小不受限制。但是，Web服务器和Web应用程序可能会对POST请求的大小进行限制。这是为了避免网络拥塞和服务器过载等问题。通常，Web服务器和Web应用程序对POST请求的大小限制在1MB到2MB之间。

**3.安全性不同**

GET方法的参数是通过URL传递的，因此可以很容易地在浏览器地址栏中看到。如果参数包含敏感信息，例如用户名和密码等，这将是一个安全风险。因此，GET方法不适合传递敏感数据。

POST方法将数据放在HTTP请求体中，因此相对于GET方法更加安全。因为POST方法的请求体不会在浏览器地址栏中显示，所以敏感信息不会暴露在URL中。但是，POST方法的请求体可能会被截获并读取，所以如果数据是敏感的，还需要采取其他安全措施。

**4.缓存机制不同**

GET方法具有缓存机制。如果浏览器请求的资源已经在本地缓存中存在，浏览器将使用缓存而不是向服务器发送请求。这可以提高Web应用程序的性能。但是，如果应用程序的数据频繁变化，使用GET方法可能会导致浏览器缓存过期，从而影响性能。

POST方法没有缓存机制。每次使用POST方法发送请求时，浏览器都会向Web服务器发送请求，Web服务器也会重新处理请求。因此，POST方法的性能相对于GET方法较低。

**5.幂等性不同**

幂等性是指对同一操作执行多次所产生的影响是相同的。在HTTP协议中，GET方法是幂等的，也就是说对同一URL执行多次GET请求，服务器的响应是相同的。因为GET方法只用于获取资源，不对服务器端的资源做任何改变。而POST方法不是幂等的，也就是说对同一URL执行多次POST请求，服务器的响应可能会不同。因为POST方法会对服务器端的资源进行改变，如果多次执行相同的POST请求，可能会导致服务器的状态发生变化。用POST方法发送请求时，浏览器都会向Web服务器发送请求，Web服务器也会重新处理请求。因此，POST方法的性能相对于GET方法较低。



[HTTPS](https://juejin.cn/post/6844904089495535624)

[TCP/IP三次握手四次挥手](https://zhuanlan.zhihu.com/p/141396896)