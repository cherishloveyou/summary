> 静态库可以简单理解为**一堆目标文件(.o/.obj)的打包体(并非二进制文件)**，而动态库可以简单理解为 一个没有main函数的可执行文件。

**静态库和动态库是相对编译期和运行期**的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入，因为在程序运行期间还需要动态库的存在。

### 静态库

- **静态库形式：** .a和.framework

1.静态库在**编译时加载**，链接时会完整的复制到可执行文件中。

2.静态库的可执行文件通常会比较大，因为所需的数据都会被整合到目标代码中，因此编译后的执行文件不需要外部库的支持，直接就能使用。

3.有多个app使用就会被复制多份，不能共享且占用更多冗余内存。

4.所有的函数都在库中，因此当修改函数时需要重新编译。

- **.a 和 .framework 的区别**

| 库的类型 | 格式          | 大小                 | Framework格式                      |
| -------- | ------------- | -------------------- | ---------------------------------- |
| 静态库   | .a .framework | 大（多个mach-o）     | Headers + .a + 签名 + 资源文件     |
| 动态库   | .framework    | 小（只有一个mach-o） | Headers + .dylib + 签名 + 资源文件 |

##### 编译进宿主App层面

| 库的类型 | 编译进App，对App大小影响的比较                               | 链接时机 |
| :------- | ------------------------------------------------------------ | -------- |
| 静态库   | 小 1.过滤掉了没有引用的头文件的代码 2.编译阶段已经链接进App中，所以会少一些链接过程需要的数据 | 编译阶段 |
| 动态库   | 大                                                           | 运行阶段 |

### 动态库

- **动态库形式：** .dylib和.framework

1.动态库在程序**运行时由系统动态加载到内存**，供程序调用，如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行。

2.动态库的文件会比较小，因为在编译过程中，数据并没有整合到目标代码中，只有在执行到该函数时才去调用库中的函数，所以首次加载时比较耗时。

3.多个程序可以共享内存中同一份库资源，系统只加载一次，多个程序可共用，节省内存空间。

4.库是动态的，因此修改库中函数时，不需要重新编译。



**静态库 好处**：

1. 模块化，分工合作，提高了代码的复用及核心技术的保密程度
2. 避免少量改动经常导致大量的重复编译连接
3. 也可以重用，注意不是共享使用

**动态库 好处：**

1. 使用动态库，可以将最终可执行文件体积缩小，将整个应用程序分模块，团队合作，进行分工，影响比较小

2. 使用动态库，多个应用程序共享内存中得同一份库文件，节省资源

3. 使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。

4. 应用插件化

5. 软件版本实时模块升级

   

6. **在其它大部分平台上，动态库都可以用于不同应用间共享， 共享可执行文件，这就大大节省了内存。**
   **iOS平台 在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，app 中使用 Cocoa Touch Framework 制作的动态库 在打包和提交 app 时会被放到 app  main bundle 的根目录 中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载。不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。**
   **苹果系统专属的framework 是共享的（如UIKit）, 但是我们自己使用 Cocoa Touch Framework 制作的动态库是放到 app bundle 中，运行在沙盒中的**





## 静态库和动态库依赖关系

- 第一种静态库互相依赖，这种情况非常常见，制作静态库的时候**只需要有被依赖的静态库头文件在就能编译出来**。但是这就意味者你要收到告诉使用者你的依赖关系。
- 第二种动态库依赖动态库，**两个动态库是相互隔离的具有隔离性**。在制作的静态库的时候需要被依赖动态库参与链接，最终具体的符号决议交给dyld来做。
- 第三种，静态库依赖动态库，也很常见，静态库制作的时候也需要动态库参与链接，但是符号的决议交给dyld来做。
- 第四种，动态库依赖静态库，这种情况就有点特殊。首先我们设想动态库编译的时候需要静态库参与编译，但是静态库交由dyld来做符号决议，这和我们前面说的就矛盾了啊。**静态库本质是一堆.o 的打包体，首先并不是二进制可执行文件，再者你无法保证主程序把静态库参与链接共同生成二进制可执行文件。**

对于第四种情况解决办法如下：

> 目前的编译器的解决办法是，首先我无法保证主程序是否包含静态库，再者静态库也无法被dyld加载，那么我直接把你静态库的.o 偷过来，共同组成一个新的二进制。**也被称做吸附性**。

如果有多个动态库依赖这个静态库就会，每个动态库为了保证自己的正确性会把静态库吸附进来。然后两个库包含了同样的静态库，于是问题就出现了。



### 处理多个动态库依赖一个静态库问题

通过前面我们知道可执文件（主程序或者动态库）在构建的链接阶段，**遇到静态库，吸附进来；遇到动态库，打标记，彼此保持独立。**

正因为动态库是保持独立的，那么我们可以自定义一个动态库把依赖的静态库吸附进来。**对外整体呈现的是动态库特性。其他的组件依赖我们自定义的动态库，由于隔离性的存在，不会出现问题。**

> 这个思路在处理项目组件化的时候非常有用，尤其是在使用Swift的项目中
>
> 

### 利用动态库处理静态库与静态库的符号冲突问题

> 需要知道，在打包IPA的时候，最终静态库会被连接到最终的那个可执行文件中。所以如果多个静态库拥有了相同的符号必定会产生符号冲突。

前面讲过可以把动态库看成一个独立的没有main函数入口的可执行文件，在iOS打包中直接copy到应用程序`.app`目录下的Frameworks目录。既然是可执行文件那么内部编译连接过程已经完成了，要处理的连接也只有在加载的时候由操作系统的dyld自动load + link。

所以最终系统在加载动态库的时候和静态库的符号根本没有丝毫关系，进而避免了链接时产生的符号冲突。

> 这一点在处理一些由于底层三方库源码不能手动修改（比如boringssl与openssl）的时候，非常有用。





[iOS 动态库和静态库](https://www.jianshu.com/p/147991ae3e5a)